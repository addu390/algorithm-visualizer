{"mappings":"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","sources":["kdtree/demo/kdTree.js"],"sourcesContent":["/**\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\n (function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports === 'object') {\n        factory(exports);\n    } else {\n        factory((root.commonJsStrict = {}));\n    }\n}(this, function (exports) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n        median,\n        node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function (a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    // Reloads a serialied tree\n    function loadTree (data) {\n      // Just need to restore the `parent` parameter\n      self.root = data;\n\n      function restoreParent (root) {\n        if (root.left) {\n          root.left.parent = root;\n          restoreParent(root.left);\n        }\n\n        if (root.right) {\n          root.right.parent = root;\n          restoreParent(root.right);\n        }\n      }\n\n      restoreParent(self.root);\n    }\n\n    // If points is not an array, assume we're loading a pre-built tree\n    if (!Array.isArray(points)) loadTree(points, metric, dimensions);\n    else this.root = buildTree(points, 0, null);\n\n    // Convert to a JSON serializable structure; this just requires removing\n    // the `parent` property\n    this.toJSON = function (src) {\n      if (!src) src = this.root;\n      var dest = new Node(src.obj, src.dimension, null);\n      if (src.left) dest.left = self.toJSON(src.left);\n      if (src.right) dest.right = self.toJSON(src.right);\n      // if (src.parent) dest.parent = self.toJSON(src.parent);\n      return dest;\n    };\n\n    this.insert = function (point) {\n      function innerSearch(node, parent) {\n\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n        newNode,\n        dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.remove = function (point) {\n      var node;\n\n      function nodeSearch(node) {\n        if (node === null) {\n          return null;\n        }\n\n        if (node.obj === point) {\n          return node;\n        }\n\n        var dimension = dimensions[node.dimension];\n\n        if (point[dimension] < node.obj[dimension]) {\n          return nodeSearch(node.left, node);\n        } else {\n          return nodeSearch(node.right, node);\n        }\n      }\n\n      function removeNode(node) {\n        var nextNode,\n          nextObj,\n          pDimension;\n\n        function findMin(node, dim) {\n          var dimension,\n            own,\n            left,\n            right,\n            min;\n\n          if (node === null) {\n            return null;\n          }\n\n          dimension = dimensions[dim];\n\n          if (node.dimension === dim) {\n            if (node.left !== null) {\n              return findMin(node.left, dim);\n            }\n            return node;\n          }\n\n          own = node.obj[dimension];\n          left = findMin(node.left, dim);\n          right = findMin(node.right, dim);\n          min = node;\n\n          if (left !== null && left.obj[dimension] < own) {\n            min = left;\n          }\n          if (right !== null && right.obj[dimension] < min.obj[dimension]) {\n            min = right;\n          }\n          return min;\n        }\n\n        if (node.left === null && node.right === null) {\n          if (node.parent === null) {\n            self.root = null;\n            return;\n          }\n\n          pDimension = dimensions[node.parent.dimension];\n\n          if (node.obj[pDimension] < node.parent.obj[pDimension]) {\n            node.parent.left = null;\n          } else {\n            node.parent.right = null;\n          }\n          return;\n        }\n\n        // If the right subtree is not empty, swap with the minimum element on the\n        // node's dimension. If it is empty, we swap the left and right subtrees and\n        // do the same.\n        if (node.right !== null) {\n          nextNode = findMin(node.right, node.dimension);\n          nextObj = nextNode.obj;\n          removeNode(nextNode);\n          node.obj = nextObj;\n        } else {\n          nextNode = findMin(node.left, node.dimension);\n          nextObj = nextNode.obj;\n          removeNode(nextNode);\n          node.right = node.left;\n          node.left = null;\n          node.obj = nextObj;\n        }\n\n      }\n\n      node = nodeSearch(self.root);\n\n      if (node === null) { return; }\n\n      removeNode(node);\n    };\n\n    this.nearest = function (point, maxNodes, maxDistance) {\n      var i,\n        result,\n        bestNodes;\n\n      bestNodes = new BinaryHeap(\n        function (e) { return -e[1]; }\n      );\n\n      function nearestSearch(node) {\n        var bestChild,\n          dimension = dimensions[node.dimension],\n          ownDistance = metric(point, node.obj),\n          linearPoint = {},\n          linearDistance,\n          otherChild,\n          i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if(self.root)\n        nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n\n    this.pointsBFS = function () {\n      var result = [];\n      if (!this.root) return result;\n      var queue  = [];\n      var bounds = { x1: 0, y1: 0, x2: 255, y2: 255 };\n      var bundle = { node: this.root, bounds: bounds, depth: 0 };\n      queue.push(bundle);\n      while(queue.length > 0) {\n        var bundle = queue.shift();\n\n        var node   = bundle.node;\n        var bounds = bundle.bounds;\n        var depth  = bundle.depth;\n        var object = node.obj;\n\n        object.dimension = node.dimension;\n        object.depth = depth;\n        node.children = [node.left, node.right];\n        object.node = node\n\n        var leftBounds, rightBounds;\n        switch(object.dimension) {\n          case 0:\n            object.x1   = object.x2 = object.red;\n            object.y1   = bounds.y1;\n            object.y2   = bounds.y2;\n            leftBounds  = { x1: bounds.x1, y1: bounds.y1, x2: object.x2, y2: bounds.y2 };\n            rightBounds = { x1: object.x1, y1: bounds.y1, x2: bounds.x2, y2: bounds.y2 };\n          break;\n          case 1:\n            object.y1   = object.y2 = object.green;\n            object.x1   = bounds.x1;\n            object.x2   = bounds.x2;\n            leftBounds  = { x1: bounds.x1, y1: bounds.y1, x2: bounds.x2, y2: object.y2 };\n            rightBounds = { x1: bounds.x1, y1: object.y1, x2: bounds.x2, y2: bounds.y2 };\n          break;\n        }\n\n        result.push(object);\n        //console.log(depth);\n\n        // Traverse the tree\n        if (node.left) {\n          queue.push({ node: node.left,  bounds: leftBounds,  depth: depth + 1 });\n        };\n        if (node.right) {\n          queue.push({ node: node.right, bounds: rightBounds, depth: depth + 1 });\n        };\n      } // while\n      return result;\n    };\n\n    this.d3tree = function () {\n      function dfs (node) {\n        if (!node) return \"null\"; // d3 expects JSON like nulls\n        var object = {};\n        object.name = node.obj.toString();\n        if (node.parent) {\n          object.parent = node.parent.obj.toString();\n        } else {\n          object.parent = \"null\"; // d3 expects JSON like nulls\n        }\n        object.children = [dfs(node.left), dfs(node.right)];\n        return object;\n      }\n      return dfs(this.root);\n    };\n\n    this.balanceFactor = function () {\n      function height(node) {\n        if (node === null) {\n          return 0;\n        }\n        return Math.max(height(node.left), height(node.right)) + 1;\n      }\n\n      function count(node) {\n        if (node === null) {\n          return 0;\n        }\n        return count(node.left) + count(node.right) + 1;\n      }\n\n      return height(self.root) / (Math.log(count(self.root)) / Math.log(2));\n    };\n  }\n\n  // Binary heap implementation from:\n  // http://eloquentjavascript.net/appendix2.html\n\n  function BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    remove: function(node) {\n      var len = this.content.length;\n      // To remove a value, we must search through the array to find\n      // it.\n      for (var i = 0; i < len; i++) {\n        if (this.content[i] == node) {\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          if (i != len - 1) {\n            this.content[i] = end;\n            if (this.scoreFunction(end) < this.scoreFunction(node))\n              this.bubbleUp(i);\n            else\n              this.sinkDown(i);\n          }\n          return;\n        }\n      }\n      throw new Error(\"Node not found.\");\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n            parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n          element = this.content[n],\n          elemScore = this.scoreFunction(element);\n\n      while(true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2, child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n              child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore)\n            swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n              child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)){\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  this.kdTree = kdTree;\n\n  exports.kdTree = kdTree;\n  exports.BinaryHeap = BinaryHeap;\n}));"],"names":["root","factory","define","amd","exports","commonJsStrict","this","Node","obj","dimension","parent","left","right","kdTree","points1","metric","dimensions","data","self","Array","isArray","buildTree","points","depth","median","node","dim","length","sort","a","b","Math","floor","slice","restoreParent","toJSON","src","dest","insert","point","newNode","insertPosition","innerSearch","remove","node1","nodeSearch","removeNode","node2","nextNode","nextObj","pDimension","findMin","own","min","nearest","maxNodes","maxDistance","i1","result","bestNodes","BinaryHeap","e","push","nearestSearch","node3","bestChild","linearDistance","otherChild","i","ownDistance","linearPoint","saveNode","distance","size","pop","peek","abs","content","pointsBFS","queue","bounds","x1","y1","x2","y2","bundle","leftBounds","rightBounds","shift","object","children","red","green","d3tree","dfs","name","toString","balanceFactor","height","max","log","count","scoreFunction","prototype","element","bubbleUp","end","sinkDown","len","Error","n","parentN","elemScore","child2N","child1N","swap","child1","child1Score","child2"],"version":3,"file":"index.8bf964aa.js.map"}