{"mappings":"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","sources":["quadtree.js","demos/3.js"],"sourcesContent":["/**\n * A Point holds (x,y) coordinates.\n * @typedef {{x:number, y: number}} Point\n */\n\n/**\n * A Boundary is an enclosed rectangular area.\n * @typedef {{x1:number, x2: number, y1: number, y2: number}} Boundary\n */\n\n/**\n * A Quadtree is a tree where each node has exactly four children.\n * Each node can contain points up until `NODE_CAPACITY`, after\n * which the node will be subdivided into four child nodes.\n *\n * @typedef {{\n *  boundary: Boundary,\n *  points: Point[],\n *  topLeftChild?: Quadtree,\n *  bottomLeftChild?: Quadtree,\n *  topRightChild?: Quadtree,\n *  bottomRightChild?: Quadtree}} Quadtree\n */\n\n/**\n * Inserts a point into the Quadtree node. If the node is already at its maximum\n * capacity, the node will first be subdivided into four child nodes. Then, the new\n * point will be added to the child node it fits into.\n *\n * @param {Quadtree} node\n * @param {Point} point\n * @param {number} nodeCapacity\n * @returns true if the point was inserted into the node or one of its child nodes\n */\nfunction insert(node, point, nodeCapacity = 4) {\n  // If the point is outside the node's boundary, return false\n  if (!contains(node.boundary, point)) {\n    return false;\n  }\n\n  // If this node has not yet reached its capacity and has not\n  // yet been subdivided, insert the point into this node\n  if (node.points.length < nodeCapacity && !node.topLeftChild) {\n    node.points.push(point);\n    return true;\n  }\n\n  // At this point, the node has either already been subdivided,\n  // or has reached its capacity but hasn't been subdivided\n\n  // If the node has reached its capacity,\n  // but hasn't been subdivided, subdivide\n  if (!node.topLeftChild) {\n    subdivide(node, nodeCapacity);\n  }\n\n  // Insert the point into its correct child node. We can try inserting into all the child nodes\n  // The wrong ones (where the point's position is outside the child node's boundary) would\n  // simply return false, until we find the correct child node.\n  if (insert(node.topLeftChild, point, nodeCapacity)) return true;\n  if (insert(node.bottomLeftChild, point, nodeCapacity)) return true;\n  if (insert(node.topRightChild, point, nodeCapacity)) return true;\n  if (insert(node.bottomRightChild, point, nodeCapacity)) return true;\n\n  // We shouldn't ever get to this point, though\n  return false;\n}\n\n/**\n * A boundary contains a point if the point is within the (x, y)\n * coordinates of the boundary's top-left and bottom-right corner\n *\n * @param {Boundary} boundary\n * @param {Point} point\n * @returns\n */\nfunction contains(boundary, point) {\n  return (\n    point.x >= boundary.x1 &&\n    point.x <= boundary.x2 &&\n    point.y >= boundary.y1 &&\n    point.y <= boundary.y2\n  );\n}\n\n/**\n * Splits a node into four child nodes and moves the\n * points in the node into their correct child nodes.\n *\n * @param {Quadtree} node\n * @param {number} nodeCapacity\n */\nfunction subdivide(node, nodeCapacity) {\n  // Create the four child nodes\n  const { x1, x2, y1, y2 } = node.boundary;\n  const midPoint = {\n    x: (x1 + x2) / 2,\n    y: (y1 + y2) / 2,\n  };\n\n  node.topLeftChild = createNode({ x1, y1, x2: midPoint.x, y2: midPoint.y });\n  node.bottomLeftChild = createNode({ x1, y1: midPoint.y, x2: midPoint.x, y2 });\n  node.topRightChild = createNode({ x1: midPoint.x, y1, x2, y2: midPoint.y });\n  node.bottomRightChild = createNode({ x1: midPoint.x, y1: midPoint.y, x2, y2 });\n\n  // Move the points in the node to the child node that should contain the point.\n  // Again, we can try inserting each point into all the child nodes. The wrong ones\n  // (where the point's position is outside the child node's boundary) would simply\n  // return false, until we find the correct child node.\n  node.points.forEach((point) => {\n    if (insert(node.topLeftChild, point, nodeCapacity)) return;\n    if (insert(node.bottomLeftChild, point, nodeCapacity)) return;\n    if (insert(node.topRightChild, point, nodeCapacity)) return;\n    if (insert(node.bottomRightChild, point, nodeCapacity)) return;\n  });\n\n  // We no longer need to keep the points in node\n  node.points = [];\n}\n\n/**\n * Returns all the points within the given boundary\n *\n * @param {Quadtree} node\n * @param {Boundary} boundary\n * @returns\n */\nfunction search(node, boundary) {\n  // If this node does not intersect with the search boundary,\n  // we know that the node and all its child nodes do not\n  // contain any points that fall into the search boundary\n  if (!intersects(node.boundary, boundary)) {\n    return [];\n  }\n\n  // If this node has not yet been subdivided, return\n  // all the points within the search boundary\n  if (!node.topLeftChild) {\n    return node.points.filter((point) => contains(boundary, point));\n  }\n\n  // If the node has been subdivided, search all\n  // the child nodes and merge the results\n  return search(node.topLeftChild, boundary)\n    .concat(search(node.bottomLeftChild, boundary))\n    .concat(search(node.topRightChild, boundary))\n    .concat(search(node.bottomRightChild, boundary));\n}\n\n/**\n * Returns true if two boundaries interesect\n *\n * @param {Boundary} b1\n * @param {Boundary} b2\n * @returns\n */\nfunction intersects(b1, b2) {\n  return (\n    // not too right\n    b1.x1 <= b2.x2 &&\n    // not too left\n    b1.x2 >= b2.x1 &&\n    // not too down\n    b1.y1 <= b2.y2 &&\n    // not too up\n    b1.y2 >= b2.y1\n  );\n}\n\n/**\n * Returns the nearest point to the given point\n *\n * @param {Quadtree} node\n * @param {Point} location\n * @param {{point: Point, distance: number} | undefined} nearestPoint\n * @returns\n */\nfunction nearest(node, location, nearestPoint = { point: null, distance: Number.MAX_VALUE }) {\n  // If this node is farther away than the nearest point, no need to check here or any of its child nodes\n  if (\n    location.x < node.boundary.x1 - nearestPoint.distance || // location too left\n    location.x > node.boundary.x2 + nearestPoint.distance || // location too right\n    location.y < node.boundary.y1 - nearestPoint.distance || // location too top\n    location.y > node.boundary.y2 + nearestPoint.distance // location too bottom\n  ) {\n    return nearestPoint;\n  }\n\n  // Not yet subdivided, return the nearest point in this node\n  if (!node.topLeftChild) {\n    node.points.forEach((point) => {\n      const d = distance(point, location);\n      if (d < nearestPoint.distance) {\n        nearestPoint.point = point;\n        nearestPoint.distance = d;\n      }\n    });\n    return nearestPoint;\n  }\n\n  // Since this node has already been subdivided, check all its child nodes.\n  // Check the child node where the location falls first, before checking\n  // the adjacent nodes, and then the opposite node.\n\n  const childNodes = [\n    node.topLeftChild,\n    node.topRightChild,\n    node.bottomLeftChild,\n    node.bottomRightChild,\n  ];\n\n  const isTop = location.y < (node.boundary.y1 + node.boundary.y2) / 2;\n  const isLeft = location.x < (node.boundary.x1 + node.boundary.x2) / 2;\n\n  // containing node\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * (1 - isLeft)], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * isLeft], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * (1 - isLeft)], location, nearestPoint);\n  // opposite node\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * isLeft], location, nearestPoint);\n\n  return nearestPoint;\n}\n\n/**\n * Returns the Euclidean distance between two points\n *\n * @param {Point} p1\n * @param {Point} p2\n * @returns\n */\nfunction distance(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\n\nfunction createNode(boundary) {\n  return { boundary, points: [] };\n}\n\nmodule.exports = { insert, search, nearest, contains, distance };\n","const d3 = require('d3');\nconst { insert } = require('../quadtree');\n\nconst width = 750;\nconst height = 300;\n\nconst svg = d3.select('#target').append('svg').attr('width', width).attr('height', height);\n\nlet quadtree = {\n  boundary: {\n    x1: 0,\n    y1: 0,\n    x2: width,\n    y2: height,\n  },\n  points: [],\n  depth: 1,\n};\n\nconst color = d3.scaleLinear().domain([0, 8]).range(['#efe', '#060']);\n\nfunction nodes(quadtree) {\n  quadtree.depth = 0;\n\n  const nodes = [];\n  visit(quadtree, (node) => {\n    nodes.push(node);\n  });\n  return nodes;\n}\n\nfunction points(quadtree) {\n  return nodes(quadtree).flatMap((node) => node.points);\n}\n\nfunction visit(node, cb) {\n  cb(node);\n\n  if (node.topLeftChild) {\n    node.topLeftChild.depth = node.depth + 1;\n    visit(node.topLeftChild, cb);\n\n    node.topRightChild.depth = node.depth + 1;\n    visit(node.topRightChild, cb);\n\n    node.bottomLeftChild.depth = node.depth + 1;\n    visit(node.bottomLeftChild, cb);\n\n    node.bottomRightChild.depth = node.depth + 1;\n    visit(node.bottomRightChild, cb);\n  }\n}\n\nlet pts;\nlet rect;\n\nfunction draw() {\n  rect = svg.selectAll('.node').data(nodes(quadtree), (node) => node.boundary);\n  rect.exit().remove();\n  rect\n    .enter()\n    .append('rect')\n    .attr('class', 'node')\n    .attr('x', function (d) {\n      return d.boundary.x1;\n    })\n    .attr('y', function (d) {\n      return d.boundary.y1;\n    })\n    .attr('width', function (d) {\n      return d.boundary.x2 - d.boundary.x1;\n    })\n    .attr('height', function (d) {\n      return d.boundary.y2 - d.boundary.y1;\n    });\n\n  svg.selectAll('.node').style('fill', function (d) {\n    return color(d.depth);\n  });\n\n  pts = svg.selectAll('.point').data(points(quadtree), (p) => p.x);\n  pts.exit().remove();\n  pts\n    .enter()\n    .append('circle')\n    .attr('class', 'point')\n    .attr('cx', function (d) {\n      return d.x;\n    })\n    .attr('cy', function (d) {\n      return d.y;\n    })\n    .attr('r', 3)\n    .transition()\n    .duration(2000)\n    .styleTween('fill', function () {\n      return d3.interpolate('red', '#999');\n    });\n  svg.selectAll('.point').raise();\n}\n\nrect = svg\n  .selectAll('.node')\n  .data(nodes(quadtree), (node) => node.boundary)\n  .enter()\n  .append('rect')\n  .attr('class', 'node')\n  .attr('x', function (d) {\n    return d.boundary.x1;\n  })\n  .attr('y', function (d) {\n    return d.boundary.y1;\n  })\n  .attr('width', function (d) {\n    return d.boundary.x2 - d.boundary.x1;\n  })\n  .attr('height', function (d) {\n    return d.boundary.y2 - d.boundary.y1;\n  });\n\npts = svg\n  .selectAll('.point')\n  .data(points(quadtree))\n  .enter()\n  .append('circle')\n  .attr('class', 'point')\n  .attr('cx', function (d) {\n    return d.x;\n  })\n  .attr('cy', function (d) {\n    return d.y;\n  })\n  .attr('r', 3);\n\nquadtree = {\n  boundary: {\n    x1: 0,\n    y1: 0,\n    x2: width,\n    y2: height,\n  },\n  points: [],\n  depth: 1,\n};\n\ndraw();\n\nconst restartButton = document.querySelector('button#restart');\nconst addPointButton = document.querySelector('button#add');\n\naddPointButton.addEventListener('click', () => {\n  insert(quadtree, { x: Math.random() * width, y: Math.random() * height });\n  draw();\n});\n\nrestartButton.addEventListener('click', () => {\n  quadtree = {\n    boundary: {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n    },\n    points: [],\n    depth: 1,\n  };\n  draw();\n});\n"],"names":["$73dc4f22fc361a3a$var$insert","node","point","nodeCapacity","$73dc4f22fc361a3a$var$contains","boundary","points","length","topLeftChild","push","x1","x2","y1","y2","midPoint","x","y","$73dc4f22fc361a3a$var$createNode","bottomLeftChild","topRightChild","bottomRightChild","forEach","$73dc4f22fc361a3a$var$subdivide","$73dc4f22fc361a3a$var$distance","p1","p2","Math","sqrt","pow","$73dc4f22fc361a3a$var$search","b1","b2","concat","filter","$73dc4f22fc361a3a$var$nearest","location","nearestPoint","distance","Number","MAX_VALUE","d","childNodes","isTop","isLeft","insert","$adcc582d0ca8bd58$var$svg","$EQ8Ao","select","append","attr","$adcc582d0ca8bd58$var$quadtree","depth","$adcc582d0ca8bd58$var$color","scaleLinear","domain","range","$adcc582d0ca8bd58$var$nodes","quadtree","nodes","$adcc582d0ca8bd58$var$visit","$adcc582d0ca8bd58$var$points","flatMap","cb","$adcc582d0ca8bd58$var$pts","$adcc582d0ca8bd58$var$rect","$adcc582d0ca8bd58$var$draw","selectAll","data","exit","remove","enter","style","p","transition","duration","styleTween","interpolate","raise","$adcc582d0ca8bd58$var$restartButton","document","querySelector","addEventListener","random"],"version":3,"file":"3.25e269ef.js.map"}