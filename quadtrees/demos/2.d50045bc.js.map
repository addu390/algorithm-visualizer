{"mappings":"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","sources":["node_modules/d3-array/src/ascending.js","node_modules/d3-array/src/bisector.js","node_modules/d3-array/src/bisect.js","node_modules/d3-array/src/number.js","node_modules/d3-array/src/ticks.js","quadtrees/demos/2.js","node_modules/d3-array/src/range.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending.js\";\n\nexport default function bisector(f) {\n  let delta = f;\n  let compare1 = f;\n  let compare2 = f;\n\n  if (f.length !== 2) {\n    delta = (d, x) => f(d) - x;\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n","import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n","export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function ticks(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step), r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step), r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","import { range } from 'd3-array';\nimport { pointer, select, selectAll } from 'd3-selection';\n\nconst width = Math.min(window.innerWidth, 750);\nconst height = 300;\n\nconst data = range((width * height) / 600).map(function () {\n  return [Math.random() * width, Math.random() * height];\n});\n\nconst svg = select('body')\n  .append('svg')\n  .attr('width', width)\n  .attr('height', height)\n  .on('click', function (e) {\n    const [x, y] = pointer(e, selectAll('svg').node());\n    ptr.attr('cx', x).attr('cy', y);\n    draw();\n  });\n\nconst midX = width / 2;\nconst midY = height / 2;\n\nconst sections = svg\n  .selectAll('.node')\n  .data([\n    { x1: 0, x2: midX, y1: 0, y2: midY },\n    { x1: midX, x2: width, y1: 0, y2: midY },\n    { x1: 0, x2: midX, y1: midY, y2: height },\n    { x1: midX, x2: width, y1: midY, y2: height },\n  ])\n  .enter()\n  .append('rect')\n  .attr('class', 'node')\n  .attr('x', function (d) {\n    return d.x1;\n  })\n  .attr('y', function (d) {\n    return d.y1;\n  })\n  .attr('width', function (d) {\n    return d.x2 - d.x1;\n  })\n  .attr('height', function (d) {\n    return d.y2 - d.y1;\n  });\n\nconst s = 100;\n\nlet rect = svg\n  .selectAll('.rect')\n  .data([{}])\n  .enter()\n  .append('rect')\n  .attr('class', 'rect')\n  .attr('width', s)\n  .attr('height', s);\n\nconst points = svg\n  .selectAll('.point')\n  .data(data)\n  .enter()\n  .append('circle')\n  .attr('class', 'point')\n  .attr('cx', function (d) {\n    return d[0];\n  })\n  .attr('cy', function (d) {\n    return d[1];\n  })\n  .attr('r', 3);\n\nlet ptr = svg\n  .append('circle')\n  .attr('id', 'pt')\n  .attr('r', 3)\n  .attr('cx', width / 2)\n  .attr('cy', height / 2)\n  .style('fill', 'yellow');\n\nfunction contains(p, b) {\n  const [x, y] = p;\n  const { x1, x2, y1, y2 } = b;\n  return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n}\n\nfunction intersects(b1, b2) {\n  return (\n    b1.x1 <= b2.x2 && // not too right\n    b1.x2 >= b2.x1 && // not too left\n    b1.y1 <= b2.y2 && // not too down\n    b1.y2 >= b2.y1 // not too up\n  );\n}\n\nfunction draw() {\n  const ptrx = +ptr.attr('cx');\n  const ptry = +ptr.attr('cy');\n\n  rect.attr('x', ptrx - s / 2).attr('y', ptry - s / 2);\n\n  const rx = +rect.attr('x');\n  const ry = +rect.attr('y');\n  const rw = +rect.attr('width');\n  const rh = +rect.attr('height');\n\n  points.each((p) => {\n    const [x, y] = p;\n    p.selected = x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;\n  });\n\n  points.classed('selected', (p) => p.selected);\n\n  const ints = [];\n  sections.each((section) => {\n    if (intersects(section, { x1: rx, x2: rx + s, y1: ry, y2: ry + s })) {\n      ints.push(section);\n    }\n  });\n\n  points.each((point) => {\n    point.scanned = false;\n    ints.forEach((int) => {\n      if (contains(point, int)) {\n        point.scanned = true;\n      }\n    });\n  });\n\n  points.classed('scanned', (p) => {\n    return p.scanned;\n  });\n}\n\ndraw();\n","export default function range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n"],"names":["a","b","NaN","f","delta","compare1","compare2","left","x","lo","hi","length","mid","d","$746b63c958399823$export$2e2bcd8739ae039","i","$e40c1fa82fd020b3$var$ascendingBisect","$eefbba663d4a424a$export$2e2bcd8739ae039","right","center","Math","sqrt","$48470b57349f7f23$var$width","min","window","innerWidth","$48470b57349f7f23$var$data","start","stop","step","n","arguments","max","ceil","range","Array","$a2cbbf3891fc0c30$export$2e2bcd8739ae039","map","random","$48470b57349f7f23$var$svg","$cNEHL","select","append","attr","on","e","y","pointer","selectAll","node","$48470b57349f7f23$var$ptr","$48470b57349f7f23$var$draw","$48470b57349f7f23$var$midX","$48470b57349f7f23$var$sections","data","x1","x2","y1","y2","$48470b57349f7f23$var$height","enter","$48470b57349f7f23$var$rect","$48470b57349f7f23$var$points","style","ptrx","ptry","$48470b57349f7f23$var$s","rx","ry","rw","rh","each","p","selected","classed","ints","section","b1","b2","push","point","scanned","forEach","int","$48470b57349f7f23$var$contains"],"version":3,"file":"2.d50045bc.js.map"}