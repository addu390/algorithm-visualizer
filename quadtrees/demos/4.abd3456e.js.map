{"mappings":"ufAiCG,SACMA,EAAOC,EAAMC,EAAOC,EAAe,GAE1C,QAAKC,EAASH,EAAKI,SAAUH,KAMzBD,EAAKK,OAAOC,OAASJ,IAAiBF,EAAKO,cAC7CP,EAAKK,OAAOG,KAAKP,IACV,IAQJD,EAAKO,cAuCT,SACgBP,EAAME,GAEvB,MAAOO,GAACA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GAAOZ,EAAKI,SAC1BS,GAAQJ,EAAKC,GAAM,EACnBI,GAAQH,EAAKC,GAAM,EACzBZ,EAAKO,aAAeQ,EAAW,IAAEN,KAAIE,EAAID,GAAIG,EAAMD,GAAIE,IACvDd,EAAKgB,gBAAkBD,EAAW,IAAEN,EAAIE,GAAIG,EAAMJ,GAAIG,KAAMD,IAC5DZ,EAAKiB,cAAgBF,EAAW,CAAEN,GAAII,KAAMF,KAAID,EAAIE,GAAIE,IACxDd,EAAKkB,iBAAmBH,EAAW,CAAEN,GAAII,EAAMF,GAAIG,KAAMJ,KAAIE,IAM7DZ,EAAKK,OAAOc,SAASlB,IACfF,EAAOC,EAAKO,aAAcN,EAAOC,IACjCH,EAAOC,EAAKgB,gBAAiBf,EAAOC,IACpCH,EAAOC,EAAKiB,cAAehB,EAAOC,IAClCH,EAAOC,EAAKkB,iBAAkBjB,EAAOC,MAI3CF,EAAKK,OAAS,GA7DZe,CAAUpB,EAAME,KAMdH,EAAOC,EAAKO,aAAcN,EAAOC,OACjCH,EAAOC,EAAKgB,gBAAiBf,EAAOC,OACpCH,EAAOC,EAAKiB,cAAehB,EAAOC,MAClCH,EAAOC,EAAKkB,iBAAkBjB,EAAOC,OAaxC,SACMC,EAASC,EAAUH,GAC1B,OACEA,EAAMoB,GAAKjB,EAASK,IACpBR,EAAMoB,GAAKjB,EAASM,IACpBT,EAAMqB,GAAKlB,EAASO,IACpBV,EAAMqB,GAAKlB,EAASQ,GAqKrB,SACMW,EAASC,EAAIC,GACpB,OAAOC,KAAKC,KAAKD,KAAKE,IAAIJ,EAAGH,EAAII,EAAGJ,EAAG,GAAKK,KAAKE,IAAIJ,EAAGF,EAAIG,EAAGH,EAAG,aAG3DP,EAAWX,GAClB,MAAO,UAAEA,EAAUC,OAAQ,IAG7BwB,EAAiB,QAAE9B,SApIhB,SACM+B,EAAO9B,EAAMI,GAIpB,OAyBkB2B,EAzBF/B,EAAKI,SAyBC4B,EAzBS5B,EA4B7B2B,EAAGtB,IAAMuB,EAAGtB,IAEZqB,EAAGrB,IAAMsB,EAAGvB,IAEZsB,EAAGpB,IAAMqB,EAAGpB,IAEZmB,EAAGnB,IAAMoB,EAAGrB,GA5BTX,EAAKO,aAMHuB,EAAO9B,EAAKO,aAAcH,GAC9B6B,OAAOH,EAAO9B,EAAKgB,gBAAiBZ,IACpC6B,OAAOH,EAAO9B,EAAKiB,cAAeb,IAClC6B,OAAOH,EAAO9B,EAAKkB,iBAAkBd,IAR/BJ,EAAKK,OAAO6B,QAAQjC,GAAUE,EAASC,EAAUH,KANjD,GAuBR,IACiB8B,EAAIC,WAoBrB,SACMG,EAAQnC,EAAMoC,EAAUC,EAAe,CAAEpC,MAAO,KAAMqC,SAAUC,OAAOC,YAE9E,GACEJ,EAASf,EAAIrB,EAAKI,SAASK,GAAK4B,EAAaC,UAC7CF,EAASf,EAAIrB,EAAKI,SAASM,GAAK2B,EAAaC,UAC7CF,EAASd,EAAItB,EAAKI,SAASO,GAAK0B,EAAaC,UAC7CF,EAASd,EAAItB,EAAKI,SAASQ,GAAKyB,EAAaC,SAE7C,OAAOD,EAIT,IAAKrC,EAAKO,aAQR,OAPAP,EAAKK,OAAOc,SAASlB,IACnB,MAAMwC,EAAIlB,EAAStB,EAAOmC,GACtBK,EAAIJ,EAAaC,WACnBD,EAAapC,MAAQA,EACrBoC,EAAaC,SAAWG,MAGrBJ,EAOT,MAAMK,EAAa,CACjB1C,EAAKO,aACLP,EAAKiB,cACLjB,EAAKgB,gBACLhB,EAAKkB,kBAGDyB,EAAQP,EAASd,GAAKtB,EAAKI,SAASO,GAAKX,EAAKI,SAASQ,IAAM,EAC7DgC,EAASR,EAASf,GAAKrB,EAAKI,SAASK,GAAKT,EAAKI,SAASM,IAAM,EAWpE,OARA2B,EAAeF,EAAQO,EAAW,GAAK,EAAIC,GAAS,GAAK,EAAIC,IAAUR,EAAUC,GAEjFA,EAAeF,EAAQO,EAAW,GAAK,EAAIC,GAAS,EAAIC,GAASR,EAAUC,GAE3EA,EAAeF,EAAQO,EAAW,EAAIC,EAAQ,GAAK,EAAIC,IAAUR,EAAUC,GAE3EA,EAAeF,EAAQO,EAAW,EAAIC,EAAQ,EAAIC,GAASR,EAAUC,aAqC3BlC,WAAUoB,qBAzBnD,SACyBtB,EAAOG,GACjC,OAAOsB,KAAKmB,IACVzC,EAASK,GAAKR,EAAMoB,EACpBpB,EAAMoB,EAAIjB,EAASM,GACnBN,EAASO,GAAKV,EAAMqB,EACpBrB,EAAMqB,EAAIlB,EAASQ,YC3OjBiB,EAAAiB,SAAAjB,EAAAS,WAAAT,EAAAkB,mBAEN,MAAMC,EAAQtB,KAAKuB,IAAIC,OAAOC,WAAY,KAGpCC,EAAOC,EAAAC,MAFE,IAGLN,EAAkB,KACzBO,KAAG,IAAO,CAAC7B,KAAK8B,SAAWR,EAJf,IAIsBtB,KAAK8B,YAEpCC,EAAW,CACfrD,SAAU,CACRK,GAAI,EACJE,GAAI,EACJD,GAAIsC,EACJpC,GAXW,KAabP,OAAQ,GACRqD,MAAO,GAETN,EAAKjC,SAAO,EAAGE,EAAGC,QACTmC,EAAU,GAAEpC,IAAGC,OAGxB,MAAMqC,EAAMN,EAAAO,OACF,QACPC,OAAO,OACPC,KAAK,QAASd,GACdc,KAAK,SAxBO,KAyBZC,GAAG,SAAS,SAAUC,GACrB,MAAO3C,EAAGC,GAAK+B,EAAAY,QAAWD,EAAGX,EAAAa,UAAa,OAAOlE,QACjD2D,EAAIO,UAAU,OAAOJ,KAAK,KAAMzC,GAAGyC,KAAK,KAAMxC,GAC9C6C,OAGJ,IAAIC,EAAOT,EACRO,UAAU,SACVG,KAAKC,EAAMb,IACXc,QACAV,OAAO,QACPC,KAAK,QAAS,QACdA,KAAK,KAAK,SAAUrB,GACnB,OAAOA,EAAErC,SAASK,MAEnBqD,KAAK,KAAK,SAAUrB,GACnB,OAAOA,EAAErC,SAASO,MAEnBmD,KAAK,SAAS,SAAUrB,GACvB,OAAOA,EAAErC,SAASM,GAAK+B,EAAErC,SAASK,MAEnCqD,KAAK,UAAU,SAAUrB,GACxB,OAAOA,EAAErC,SAASQ,GAAK6B,EAAErC,SAASO,MAGlC6D,EAAMb,EACPO,UAAU,UACVG,MAgCaI,EAhCDhB,EAiCNa,EAAMG,GAAUC,SAAS1E,GAASA,EAAKK,WAhC7CkE,QACAV,OAAO,UACPC,KAAK,QAAS,SACdA,KAAK,MAAM,SAAUrB,GACpB,OAAOA,EAAEpB,KAEVyC,KAAK,MAAM,SAAUrB,GACpB,OAAOA,EAAEnB,KAEVwC,KAAK,IAAK,OAsBGW,EApBhB,IAAIE,EAAMhB,EACPE,OAAO,UACPC,KAAK,KAAM,MACXA,KAAK,IAAK,GACVA,KAAK,KAAMd,EAAQ,GACnBc,KAAK,KAAMc,KACXC,MAAM,OAAQ,UAEjB,MAAMC,EAAQzB,EAAA0B,cAAiBC,OAAO,CAAC,EAAG,IAAI1B,MAAM,CAAC,OAAQ,kBAEpDgB,EAAMG,GACbA,EAASf,MAAQ,EAEjB,MAAMuB,EAAQ,GAId,OAHAC,EAAMT,GAAWzE,IACfiF,EAAMzE,KAAKR,MAENiF,WAOAC,EAAMlF,EAAMmF,GACnBA,EAAGnF,GAECA,EAAKO,eACPP,EAAKO,aAAamD,MAAQ1D,EAAK0D,MAAQ,EACvCwB,EAAMlF,EAAKO,aAAc4E,GAEzBnF,EAAKiB,cAAcyC,MAAQ1D,EAAK0D,MAAQ,EACxCwB,EAAMlF,EAAKiB,cAAekE,GAE1BnF,EAAKgB,gBAAgB0C,MAAQ1D,EAAK0D,MAAQ,EAC1CwB,EAAMlF,EAAKgB,gBAAiBmE,GAE5BnF,EAAKkB,iBAAiBwC,MAAQ1D,EAAK0D,MAAQ,EAC3CwB,EAAMlF,EAAKkB,iBAAkBiE,aAIxBhB,IACPQ,EAAMtB,EAAAa,UAAa,OACnB,MAAM7C,GAAKsD,EAAIb,KAAK,MACdxC,GAAKqD,EAAIb,KAAK,MAEpBU,EAAIY,MAAM3C,IACRA,EAAE4C,QAAU5C,EAAE6C,UAAW,KAE3BlB,EAAKgB,MAAM3C,IACTA,EAAE8C,SAAU,KAGOC,EAAQ/B,EAAU,GAAEpC,IAAGC,IAC/BrB,MAAMqF,UAAW,EAE9Bd,EAAIiB,QAAQ,WAAYhD,GAAMA,EAAE4C,UAChCb,EAAIiB,QAAQ,YAAahD,GAAMA,EAAE6C,WACjClB,EAAKS,MAAM,QAASpC,GAAOA,EAAE8C,QAAUT,EAAMrC,EAAEiB,OAAS,kBAGjD8B,EAAQxF,EAAMoC,EAAUC,EAAe,CAAEpC,MAAO,KAAMqC,SAAUC,OAAOC,YAG9E,GAFAxC,EAAKuF,SAAU,EAEbG,EAAqBtD,EAAUpC,EAAKI,UAAYiC,EAAaC,SAC7D,OAAOD,EAGT,IAAKrC,EAAKO,aASR,OARAP,EAAKK,OAAOc,SAASlB,IACnBA,EAAMoF,SAAU,EAChB,MAAM5C,EAACkD,EAAYvD,EAAUnC,GACzBwC,EAAIJ,EAAaC,WACnBD,EAAapC,MAAQA,EACrBoC,EAAaC,SAAWG,MAGrBJ,EAGT,MAAMK,EAAa,CACjB1C,EAAKO,aACLP,EAAKiB,cACLjB,EAAKgB,gBACLhB,EAAKkB,kBAGDyB,EAAQP,EAASd,GAAKtB,EAAKI,SAASO,GAAKX,EAAKI,SAASQ,IAAM,EAC7DgC,EAASR,EAASf,GAAKrB,EAAKI,SAASK,GAAKT,EAAKI,SAASM,IAAM,EAMpE,OAJA2B,EAAemD,EAAQ9C,EAAW,GAAK,EAAIC,GAAS,GAAK,EAAIC,IAAUR,EAAUC,GACjFA,EAAemD,EAAQ9C,EAAW,GAAK,EAAIC,GAAS,EAAIC,GAASR,EAAUC,GAC3EA,EAAemD,EAAQ9C,EAAW,EAAIC,EAAQ,GAAK,EAAIC,IAAUR,EAAUC,GAC3EA,EAAemD,EAAQ9C,EAAW,EAAIC,EAAQ,EAAIC,GAASR,EAAUC,GAIvE8B","sources":["quadtrees/quadtree.js","quadtrees/demos/4.js"],"sourcesContent":["/**\n * A Point holds (x,y) coordinates.\n * @typedef {{x:number, y: number}} Point\n */\n\n/**\n * A Boundary is an enclosed rectangular area.\n * @typedef {{x1:number, x2: number, y1: number, y2: number}} Boundary\n */\n\n/**\n * A Quadtree is a tree where each node has exactly four children.\n * Each node can contain points up until `NODE_CAPACITY`, after\n * which the node will be subdivided into four child nodes.\n *\n * @typedef {{\n *  boundary: Boundary,\n *  points: Point[],\n *  topLeftChild?: Quadtree,\n *  bottomLeftChild?: Quadtree,\n *  topRightChild?: Quadtree,\n *  bottomRightChild?: Quadtree}} Quadtree\n */\n\n/**\n * Inserts a point into the Quadtree node. If the node is already at its maximum\n * capacity, the node will first be subdivided into four child nodes. Then, the new\n * point will be added to the child node it fits into.\n *\n * @param {Quadtree} node\n * @param {Point} point\n * @param {number} nodeCapacity\n * @returns true if the point was inserted into the node or one of its child nodes\n */\nfunction insert(node, point, nodeCapacity = 4) {\n  // If the point is outside the node's boundary, return false\n  if (!contains(node.boundary, point)) {\n    return false;\n  }\n\n  // If this node has not yet reached its capacity and has not\n  // yet been subdivided, insert the point into this node\n  if (node.points.length < nodeCapacity && !node.topLeftChild) {\n    node.points.push(point);\n    return true;\n  }\n\n  // At this point, the node has either already been subdivided,\n  // or has reached its capacity but hasn't been subdivided\n\n  // If the node has reached its capacity,\n  // but hasn't been subdivided, subdivide\n  if (!node.topLeftChild) {\n    subdivide(node, nodeCapacity);\n  }\n\n  // Insert the point into its correct child node. We can try inserting into all the child nodes\n  // The wrong ones (where the point's position is outside the child node's boundary) would\n  // simply return false, until we find the correct child node.\n  if (insert(node.topLeftChild, point, nodeCapacity)) return true;\n  if (insert(node.bottomLeftChild, point, nodeCapacity)) return true;\n  if (insert(node.topRightChild, point, nodeCapacity)) return true;\n  if (insert(node.bottomRightChild, point, nodeCapacity)) return true;\n\n  // We shouldn't ever get to this point, though\n  return false;\n}\n\n/**\n * A boundary contains a point if the point is within the (x, y)\n * coordinates of the boundary's top-left and bottom-right corner\n *\n * @param {Boundary} boundary\n * @param {Point} point\n * @returns\n */\nfunction contains(boundary, point) {\n  return (\n    point.x >= boundary.x1 &&\n    point.x <= boundary.x2 &&\n    point.y >= boundary.y1 &&\n    point.y <= boundary.y2\n  );\n}\n\n/**\n * Splits a node into four child nodes and moves the\n * points in the node into their correct child nodes.\n *\n * @param {Quadtree} node\n * @param {number} nodeCapacity\n */\nfunction subdivide(node, nodeCapacity) {\n  // Create the four child nodes\n  const { x1, x2, y1, y2 } = node.boundary;\n  const midX = (x1 + x2) / 2;\n  const midY = (y1 + y2) / 2;\n  node.topLeftChild = createNode({ x1, y1, x2: midX, y2: midY });\n  node.bottomLeftChild = createNode({ x1, y1: midY, x2: midX, y2 });\n  node.topRightChild = createNode({ x1: midX, y1, x2, y2: midY });\n  node.bottomRightChild = createNode({ x1: midX, y1: midY, x2, y2 });\n\n  // Move the points in the node to the child node that should contain the point.\n  // Again, we can try inserting each point into all the child nodes. The wrong ones\n  // (where the point's position is outside the child node's boundary) would simply\n  // return false, until we find the correct child node.\n  node.points.forEach((point) => {\n    if (insert(node.topLeftChild, point, nodeCapacity)) return;\n    if (insert(node.bottomLeftChild, point, nodeCapacity)) return;\n    if (insert(node.topRightChild, point, nodeCapacity)) return;\n    if (insert(node.bottomRightChild, point, nodeCapacity)) return;\n  });\n\n  // We no longer need to keep the points in node\n  node.points = [];\n}\n\n/**\n * Returns all the points within the given boundary\n *\n * @param {Quadtree} node\n * @param {Boundary} boundary\n * @returns\n */\nfunction search(node, boundary) {\n  // If this node does not intersect with the search boundary,\n  // we know that the node and all its child nodes do not\n  // contain any points that fall into the search boundary\n  if (!intersects(node.boundary, boundary)) {\n    return [];\n  }\n\n  // If this node has not yet been subdivided, return\n  // all the points within the search boundary\n  if (!node.topLeftChild) {\n    return node.points.filter((point) => contains(boundary, point));\n  }\n\n  // If the node has been subdivided, search all\n  // the child nodes and merge the results\n  return search(node.topLeftChild, boundary)\n    .concat(search(node.bottomLeftChild, boundary))\n    .concat(search(node.topRightChild, boundary))\n    .concat(search(node.bottomRightChild, boundary));\n}\n\n/**\n * Returns true if two boundaries interesect\n *\n * @param {Boundary} b1\n * @param {Boundary} b2\n * @returns\n */\nfunction intersects(b1, b2) {\n  return (\n    // not too right\n    b1.x1 <= b2.x2 &&\n    // not too left\n    b1.x2 >= b2.x1 &&\n    // not too down\n    b1.y1 <= b2.y2 &&\n    // not too up\n    b1.y2 >= b2.y1\n  );\n}\n\n/**\n * Returns the nearest point to the given point\n *\n * @param {Quadtree} node\n * @param {Point} location\n * @param {{point: Point, distance: number} | undefined} nearestPoint\n * @returns\n */\nfunction nearest(node, location, nearestPoint = { point: null, distance: Number.MAX_VALUE }) {\n  // If this node is farther away than the nearest point, no need to check here or any of its child nodes\n  if (\n    location.x < node.boundary.x1 - nearestPoint.distance || // location too left\n    location.x > node.boundary.x2 + nearestPoint.distance || // location too right\n    location.y < node.boundary.y1 - nearestPoint.distance || // location too top\n    location.y > node.boundary.y2 + nearestPoint.distance // location too bottom\n  ) {\n    return nearestPoint;\n  }\n\n  // Not yet subdivided, return the nearest point in this node\n  if (!node.topLeftChild) {\n    node.points.forEach((point) => {\n      const d = distance(point, location);\n      if (d < nearestPoint.distance) {\n        nearestPoint.point = point;\n        nearestPoint.distance = d;\n      }\n    });\n    return nearestPoint;\n  }\n\n  // Since this node has already been subdivided, check all its child nodes.\n  // Check the child node where the location falls first, before checking\n  // the adjacent nodes, and then the opposite node.\n\n  const childNodes = [\n    node.topLeftChild,\n    node.topRightChild,\n    node.bottomLeftChild,\n    node.bottomRightChild,\n  ];\n\n  const isTop = location.y < (node.boundary.y1 + node.boundary.y2) / 2;\n  const isLeft = location.x < (node.boundary.x1 + node.boundary.x2) / 2;\n\n  // containing node\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * (1 - isLeft)], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * isLeft], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * (1 - isLeft)], location, nearestPoint);\n  // opposite node\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * isLeft], location, nearestPoint);\n\n  return nearestPoint;\n}\n\n/**\n * Returns the distance between a point and a boundary as the\n * maximum distance along each of the axes\n *\n * @param {Point} point\n * @param {Boundary} boundary\n * @returns\n */\nfunction distanceToBoundary(point, boundary) {\n  return Math.max(\n    boundary.x1 - point.x,\n    point.x - boundary.x2,\n    boundary.y1 - point.y,\n    point.y - boundary.y2\n  );\n}\n\n/**\n * Returns the Euclidean distance between two points\n *\n * @param {Point} p1\n * @param {Point} p2\n * @returns\n */\nfunction distance(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\n\nfunction createNode(boundary) {\n  return { boundary, points: [] };\n}\n\nmodule.exports = { insert, search, nearest, contains, distance, distanceToBoundary };\n","const d3 = require('d3');\nconst { insert, distance, distanceToBoundary } = require('../quadtree');\n\nconst width = Math.min(window.innerWidth, 750);\nconst height = 300;\n\nconst data = d3\n  .range((width * height) / 600)\n  .map(() => [Math.random() * width, Math.random() * height]);\n\nconst quadtree = {\n  boundary: {\n    x1: 0,\n    y1: 0,\n    x2: width,\n    y2: height,\n  },\n  points: [],\n  depth: 1,\n};\ndata.forEach(([x, y]) => {\n  insert(quadtree, { x, y });\n});\n\nconst svg = d3\n  .select('body')\n  .append('svg')\n  .attr('width', width)\n  .attr('height', height)\n  .on('click', function (e) {\n    const [x, y] = d3.pointer(e, d3.selectAll('svg').node());\n    svg.selectAll('#pt').attr('cx', x).attr('cy', y);\n    draw();\n  });\n\nlet rect = svg\n  .selectAll('.node')\n  .data(nodes(quadtree))\n  .enter()\n  .append('rect')\n  .attr('class', 'node')\n  .attr('x', function (d) {\n    return d.boundary.x1;\n  })\n  .attr('y', function (d) {\n    return d.boundary.y1;\n  })\n  .attr('width', function (d) {\n    return d.boundary.x2 - d.boundary.x1;\n  })\n  .attr('height', function (d) {\n    return d.boundary.y2 - d.boundary.y1;\n  });\n\nlet pts = svg\n  .selectAll('.point')\n  .data(points(quadtree))\n  .enter()\n  .append('circle')\n  .attr('class', 'point')\n  .attr('cx', function (d) {\n    return d.x;\n  })\n  .attr('cy', function (d) {\n    return d.y;\n  })\n  .attr('r', 3);\n\nlet ptr = svg\n  .append('circle')\n  .attr('id', 'pt')\n  .attr('r', 3)\n  .attr('cx', width / 2)\n  .attr('cy', height / 2)\n  .style('fill', 'yellow');\n\nconst color = d3.scaleLinear().domain([0, 8]).range(['#efe', '#060']);\n\nfunction nodes(quadtree) {\n  quadtree.depth = 0;\n\n  const nodes = [];\n  visit(quadtree, (node) => {\n    nodes.push(node);\n  });\n  return nodes;\n}\n\nfunction points(quadtree) {\n  return nodes(quadtree).flatMap((node) => node.points);\n}\n\nfunction visit(node, cb) {\n  cb(node);\n\n  if (node.topLeftChild) {\n    node.topLeftChild.depth = node.depth + 1;\n    visit(node.topLeftChild, cb);\n\n    node.topRightChild.depth = node.depth + 1;\n    visit(node.topRightChild, cb);\n\n    node.bottomLeftChild.depth = node.depth + 1;\n    visit(node.bottomLeftChild, cb);\n\n    node.bottomRightChild.depth = node.depth + 1;\n    visit(node.bottomRightChild, cb);\n  }\n}\n\nfunction draw() {\n  ptr = d3.selectAll('#pt');\n  const x = +ptr.attr('cx');\n  const y = +ptr.attr('cy');\n\n  pts.each((d) => {\n    d.scanned = d.selected = false;\n  });\n  rect.each((d) => {\n    d.visited = false;\n  });\n\n  const nearestPoint = nearest(quadtree, { x, y });\n  nearestPoint.point.selected = true;\n\n  pts.classed('scanned', (d) => d.scanned);\n  pts.classed('selected', (d) => d.selected);\n  rect.style('fill', (d) => (d.visited ? color(d.depth) : 'none'));\n}\n\nfunction nearest(node, location, nearestPoint = { point: null, distance: Number.MAX_VALUE }) {\n  node.visited = true;\n\n  if (distanceToBoundary(location, node.boundary) > nearestPoint.distance) {\n    return nearestPoint;\n  }\n\n  if (!node.topLeftChild) {\n    node.points.forEach((point) => {\n      point.scanned = true;\n      const d = distance(location, point);\n      if (d < nearestPoint.distance) {\n        nearestPoint.point = point;\n        nearestPoint.distance = d;\n      }\n    });\n    return nearestPoint;\n  }\n\n  const childNodes = [\n    node.topLeftChild,\n    node.topRightChild,\n    node.bottomLeftChild,\n    node.bottomRightChild,\n  ];\n\n  const isTop = location.y < (node.boundary.y1 + node.boundary.y2) / 2;\n  const isLeft = location.x < (node.boundary.x1 + node.boundary.x2) / 2;\n\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * (1 - isLeft)], location, nearestPoint);\n  nearestPoint = nearest(childNodes[2 * (1 - isTop) + 1 * isLeft], location, nearestPoint);\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * (1 - isLeft)], location, nearestPoint);\n  nearestPoint = nearest(childNodes[2 * isTop + 1 * isLeft], location, nearestPoint);\n  return nearestPoint;\n}\n\ndraw();\n"],"names":["$bf4dd4fcba92df12$var$insert","node","point","nodeCapacity","$bf4dd4fcba92df12$var$contains","boundary","points","length","topLeftChild","push","x1","x2","y1","y2","midX","midY","$bf4dd4fcba92df12$var$createNode","bottomLeftChild","topRightChild","bottomRightChild","forEach","$bf4dd4fcba92df12$var$subdivide","x","y","$bf4dd4fcba92df12$var$distance","p1","p2","Math","sqrt","pow","$bf4dd4fcba92df12$exports","$bf4dd4fcba92df12$var$search","b1","b2","concat","filter","$bf4dd4fcba92df12$var$nearest","location","nearestPoint","distance","Number","MAX_VALUE","d","childNodes","isTop","isLeft","max","insert","distanceToBoundary","$f1526d6baaafba7f$var$width","min","window","innerWidth","$f1526d6baaafba7f$var$data","$h36xl","range","map","random","$f1526d6baaafba7f$var$quadtree","depth","$f1526d6baaafba7f$var$svg","select","append","attr","on","e","pointer","selectAll","$f1526d6baaafba7f$var$draw","$f1526d6baaafba7f$var$rect","data","$f1526d6baaafba7f$var$nodes","enter","$f1526d6baaafba7f$var$pts","quadtree","flatMap","$f1526d6baaafba7f$var$ptr","$f1526d6baaafba7f$var$height","style","$f1526d6baaafba7f$var$color","scaleLinear","domain","nodes","$f1526d6baaafba7f$var$visit","cb","each","scanned","selected","visited","$f1526d6baaafba7f$var$nearest","classed","$f1526d6baaafba7f$require$distanceToBoundary","$f1526d6baaafba7f$require$distance"],"version":3,"file":"4.abd3456e.js.map"}