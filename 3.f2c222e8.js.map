{"mappings":"qfAqCG,SACMA,EAAOC,EAAMC,GAEpB,QAAKC,EAASF,EAAKG,SAAUF,KAMzBD,EAAKI,OAAOC,OA7CI,IA6CuBL,EAAKM,cAC9CN,EAAKI,OAAOG,KAAKN,IACV,IAQJD,EAAKM,cAsCT,SACgBN,GAEjB,MAAKQ,QAAGA,EAAOC,YAAEA,GAAgBT,EAAKG,SAChCO,EAAQ,CACZC,GAAIH,EAAQG,EAAIF,EAAYE,GAAK,EACjCC,GAAIJ,EAAQI,EAAIH,EAAYG,GAAK,GAGnCZ,EAAKM,aAAeO,EAAU,CAAGF,EAAGH,EAAQG,EAAGC,EAAGJ,EAAQI,IAAOD,EAAGD,EAASC,EAAGC,EAAGF,EAASE,IAC5FZ,EAAKc,gBAAkBD,EAAU,CAC7BF,EAAGH,EAAQG,EAAGC,EAAGF,EAASE,IAC1BD,EAAGD,EAASC,EAAGC,EAAGH,EAAYG,IAElCZ,EAAKe,cAAgBF,EAAU,CAC3BF,EAAGD,EAASC,EAAGC,EAAGJ,EAAQI,IAC1BD,EAAGF,EAAYE,EAAGC,EAAGF,EAASE,IAElCZ,EAAKgB,iBAAmBH,EAAU,CAC9BF,EAAGD,EAASC,EAAGC,EAAGF,EAASE,IAC3BD,EAAGF,EAAYE,EAAGC,EAAGH,EAAYG,IAOrCZ,EAAKI,OAAOa,SAAShB,IACfF,EAAOC,EAAKM,aAAcL,IAC1BF,EAAOC,EAAKc,gBAAiBb,IAC7BF,EAAOC,EAAKe,cAAed,IAC3BF,EAAOC,EAAKgB,iBAAkBf,MAIpCD,EAAKI,OAAM,GAxETc,CAAUlB,KAMRD,EAAOC,EAAKM,aAAcL,OAC1BF,EAAOC,EAAKc,gBAAiBb,OAC7BF,EAAOC,EAAKe,cAAed,MAC3BF,EAAOC,EAAKgB,iBAAkBf,OAajC,SACMC,EAASC,EAAUF,UAExBA,EAAMU,GAAKR,EAASK,QAAQG,GAC5BV,EAAMU,GAAKR,EAASM,YAAYE,GAChCV,EAAMW,GAAKT,EAASK,QAAQI,GAC5BX,EAAMW,GAAKT,EAASM,YAAYG,EAwKjC,SACMO,EAASC,EAAIC,UACbC,KAAKC,KAAKD,KAAKE,IAAIJ,EAAGT,EAAIU,EAAGV,EAAG,GAAKW,KAAKE,IAAIJ,EAAGR,EAAIS,EAAGT,EAAG,aAG3DC,EAAWL,EAASC,UAClBN,SAAQ,SAAIK,cAASC,GAAeL,OAAM,UAGvC,QAAKL,SA5HhB,SACM0B,EAAOzB,EAAMG,GAIpB,OAyBkBuB,EAzBF1B,EAAKG,SAyBCwB,EAzBSxB,EA4B7BuB,EAAGlB,QAAQG,GAAKgB,EAAGlB,YAAYE,GAE/Be,EAAGjB,YAAYE,GAAKgB,EAAGnB,QAAQG,GAE/Be,EAAGlB,QAAQI,GAAKe,EAAGlB,YAAYG,GAE/Bc,EAAGjB,YAAYG,GAAKe,EAAGnB,QAAQI,EA5B5BZ,EAAKM,aAMHmB,EAAOzB,EAAKM,aAAcH,GAC9ByB,OAAOH,EAAOzB,EAAKc,gBAAiBX,IACpCyB,OAAOH,EAAOzB,EAAKe,cAAeZ,IAClCyB,OAAOH,EAAOzB,EAAKgB,iBAAkBb,IAR/BH,EAAKI,OAAOyB,QAAQ5B,GAAUC,EAASC,EAAUF,KAPnB,GAwBtC,IACiByB,EAAIC,WAoBrB,SACMG,EACP9B,EACA+B,EACAC,EAAY,CACV/B,MAAO,KACPgC,SAAUd,EAASnB,EAAKG,SAASK,QAASR,EAAKG,SAASM,eAI1D,GACEa,KAAKY,IAAIH,EAASpB,EAAIX,EAAKG,SAASK,QAAQG,GAAKqB,EAAaC,UAC9DX,KAAKY,IAAIH,EAASpB,EAAIX,EAAKG,SAASM,YAAYE,GAAKqB,EAAaC,UAClEX,KAAKY,IAAIH,EAASnB,EAAIZ,EAAKG,SAASK,QAAQI,GAAKoB,EAAaC,UAC9DX,KAAKY,IAAIH,EAASnB,EAAIZ,EAAKG,SAASM,YAAYG,GAAKoB,EAAaC,SAAQ,OAEnED,EAIT,IAAKhC,EAAKM,oBACRN,EAAKI,OAAOa,SAASkB,IACnB,MAAMC,EAAIjB,EAASgB,EAAWJ,GAC1BK,EAAIJ,EAAaC,WACnBD,EAAa/B,MAAQkC,EACrBH,EAAaC,SAAWG,MAGrBJ,EAOT,MAAMK,EAAU,CACdrC,EAAKM,aACLN,EAAKe,cACLf,EAAKc,gBACLd,EAAKgB,kBAIDsB,EAAKP,EAASnB,GAAKZ,EAAKG,SAASK,QAAQI,EAAIZ,EAAKG,SAASM,YAAYG,GAAK,EAE5E2B,EAAKR,EAASpB,GAAKX,EAAKG,SAASK,QAAQG,EAAIX,EAAKG,SAASM,YAAYE,GAAK,SAGlFqB,EAAeF,EAAQO,EAAW,GAAK,EAAIC,GAAM,GAAK,EAAIC,IAAMR,EAAUC,GAE1EA,EAAeF,EAAQO,EAAW,GAAK,EAAIC,GAAM,EAAIC,GAAKR,EAAUC,GAEpEA,EAAeF,EAAQO,EAAW,EAAIC,EAAK,GAAK,EAAIC,IAAMR,EAAUC,GAEpEA,EAAeF,EAAQO,EAAW,EAAIC,EAAK,EAAIC,GAAKR,EAAUC,KCjP1DQ,OAEN,MAGMC,EAAMC,EAAAC,OAAS,QAASC,OAAM,OAAQC,KAAI,QAHlC,KAGmDA,KAAI,SAFtD,KAITC,EAAQ,CACZ3C,SAAQ,CACNK,QAAO,CAAIG,EAAG,EAAGC,EAAG,GACpBH,YAAW,CAAIE,EARL,IAQeC,EAPd,MASbR,OAAM,GACN2C,MAAO,GAGHC,EAAQN,EAAAO,cAAiBC,OAAM,CAAE,EAAG,IAAIC,MAAK,0BAE1CC,EAAMC,GACbA,EAASN,MAAQ,EAEjB,MAAMO,EAAK,UACXC,EAAMF,GAAWrD,IACfsD,EAAM/C,KAAKP,MAENsD,WAGAE,EAAOH,UACPD,EAAMC,GAAUI,SAASzD,GAASA,EAAKI,kBAGvCmD,EAAMvD,EAAM0D,GACnBA,EAAG1D,GAECA,EAAKM,eACPN,EAAKM,aAAayC,MAAQ/C,EAAK+C,MAAQ,EACvCQ,EAAMvD,EAAKM,aAAcoD,GAEzB1D,EAAKe,cAAcgC,MAAQ/C,EAAK+C,MAAQ,EACxCQ,EAAMvD,EAAKe,cAAe2C,GAE1B1D,EAAKc,gBAAgBiC,MAAQ/C,EAAK+C,MAAQ,EAC1CQ,EAAMvD,EAAKc,gBAAiB4C,GAE5B1D,EAAKgB,iBAAiB+B,MAAQ/C,EAAK+C,MAAQ,EAC3CQ,EAAMvD,EAAKgB,iBAAkB0C,IAIjC,IAAIC,EACAC,EA0CJA,EAAOnB,EACJoB,UAAS,SACTC,KAAKV,EAAMN,IACXiB,QACAnB,OAAM,QACNC,KAAI,QAAQ,QACZA,KAAI,KAAI,SAAYT,UACZA,EAAEjC,SAASK,QAAQG,KAE3BkC,KAAI,KAAI,SAAYT,UACZA,EAAEjC,SAASK,QAAQI,KAE3BiC,KAAI,SAAQ,SAAYT,UAChBA,EAAEjC,SAASM,YAAYE,EAAIyB,EAAEjC,SAASK,QAAQG,KAEtDkC,KAAI,UAAS,SAAYT,UACjBA,EAAEjC,SAASM,YAAYG,EAAIwB,EAAEjC,SAASK,QAAQI,KAGzD+C,EAAMlB,EACHoB,UAAS,UACTC,KAAKN,EAAOV,IACZiB,QACAnB,OAAM,UACNC,KAAI,QAAQ,SACZA,KAAI,MAAK,SAAYT,UACbA,EAAEzB,KAEVkC,KAAI,MAAK,SAAYT,UACbA,EAAExB,KAEViC,KAAI,IAAM,OAER,IAAImB,EAAI,EAAGA,EAAI,IAAKA,IAACC,EACjBnB,EAAQ,CAAInC,EA7HP,IA6HUW,KAAK4C,SAAkBtD,EA5HhC,IA4HmCU,KAAK4C,WAzErDN,EAAOA,EAAKE,KAAKV,EAAMN,IACvBc,EAAKO,OAAOC,SACZR,EACGG,QACAnB,OAAM,QACNC,KAAI,QAAQ,QACZA,KAAI,KAAI,SAAYT,UACZA,EAAEjC,SAASK,QAAQG,KAE3BkC,KAAI,KAAI,SAAYT,UACZA,EAAEjC,SAASK,QAAQI,KAE3BiC,KAAI,SAAQ,SAAYT,UAChBA,EAAEjC,SAASM,YAAYE,EAAIyB,EAAEjC,SAASK,QAAQG,KAEtDkC,KAAI,UAAS,SAAYT,UACjBA,EAAEjC,SAASM,YAAYG,EAAIwB,EAAEjC,SAASK,QAAQI,KAGzD+C,EAAMA,EAAIG,KAAKN,EAAOV,IACtBa,EAAIQ,OAAOC,SACXT,EACGI,QACAnB,OAAM,UACNC,KAAI,QAAQ,SACZA,KAAI,MAAK,SAAYT,UACbA,EAAEzB,KAEVkC,KAAI,MAAK,SAAYT,UACbA,EAAExB,KAEViC,KAAI,IAAM,GAEbJ,EAAIoB,UAAS,SAAUQ,MAAK,QAAO,SAAYjC,UACtCY,EAAMZ,EAAEW","sources":["quadtree.js","3.js"],"sourcesContent":["// Maximum number of points that can be held in a node\nconst NODE_CAPACITY = 4;\n\n/**\n * A Point holds (x,y) coordinates.\n * @typedef {{x:number, y: number}} Point\n */\n\n/**\n * A Boundary is an enclosed rectangular area.\n * @typedef {{topLeft: Point, bottomRight: Point}} Boundary\n */\n\n// TODO: Change top-left child, etc to just children?\n\n/**\n * A Quadtree is a tree where each node has exactly four children.\n * Each node can contain points up until `NODE_CAPACITY`, after\n * which the node will be subdivided into four child nodes.\n *\n * @typedef {{\n *  boundary: Boundary,\n *  points: Point[],\n *  topLeftChild?: Quadtree,\n *  bottomLeftChild?: Quadtree,\n *  topRightChild?: Quadtree,\n *  bottomRightChild?: Quadtree}} Quadtree\n */\n\n/**\n * Inserts a point into the Quadtree node. If the node is already at its maximum\n * capacity, the node will first be subdivided into four child nodes. Then, the new\n * point will be added to the child node it fits into.\n *\n * @param {Quadtree} node\n * @param {Point} point\n * @returns true if the point was inserted into the node or one of its child nodes\n */\nfunction insert(node, point) {\n  // If the point is outside the node's boundary, return false\n  if (!contains(node.boundary, point)) {\n    return false;\n  }\n\n  // If this node has not yet reached its capacity and has not\n  // yet been subdivided, insert the point into this node\n  if (node.points.length < NODE_CAPACITY && !node.topLeftChild) {\n    node.points.push(point);\n    return true;\n  }\n\n  // At this point, the node has either already been subdivided,\n  // or has reached its capacity but hasn't been subdivided\n\n  // If the node has reached its capacity,\n  // but hasn't been subdivided, subdivide\n  if (!node.topLeftChild) {\n    subdivide(node);\n  }\n\n  // Insert the point into its correct child node. We can try inserting into all the child nodes\n  // The wrong ones (where the point's position is outside the child node's boundary) would\n  // simply return false, until we find the correct child node.\n  if (insert(node.topLeftChild, point)) return true;\n  if (insert(node.bottomLeftChild, point)) return true;\n  if (insert(node.topRightChild, point)) return true;\n  if (insert(node.bottomRightChild, point)) return true;\n\n  // We shouldn't ever get to this point, though\n  return false;\n}\n\n/**\n * A boundary contains a point if the point is within the (x, y)\n * coordinates of the boundary's top-left and bottom-right corner\n *\n * @param {Boundary} boundary\n * @param {Point} point\n * @returns\n */\nfunction contains(boundary, point) {\n  return (\n    point.x >= boundary.topLeft.x &&\n    point.x <= boundary.bottomRight.x &&\n    point.y >= boundary.topLeft.y &&\n    point.y <= boundary.bottomRight.y\n  );\n}\n\n/**\n * Splits a node into four child nodes and moves the\n * points in the node into their correct child nodes.\n *\n * @param {Quadtree} node\n */\nfunction subdivide(node) {\n  // Create the four child nodes\n  const { topLeft, bottomRight } = node.boundary;\n  const midPoint = {\n    x: (topLeft.x + bottomRight.x) / 2,\n    y: (topLeft.y + bottomRight.y) / 2,\n  };\n\n  node.topLeftChild = createNode({ x: topLeft.x, y: topLeft.y }, { x: midPoint.x, y: midPoint.y });\n  node.bottomLeftChild = createNode(\n    { x: topLeft.x, y: midPoint.y },\n    { x: midPoint.x, y: bottomRight.y }\n  );\n  node.topRightChild = createNode(\n    { x: midPoint.x, y: topLeft.y },\n    { x: bottomRight.x, y: midPoint.y }\n  );\n  node.bottomRightChild = createNode(\n    { x: midPoint.x, y: midPoint.y },\n    { x: bottomRight.x, y: bottomRight.y }\n  );\n\n  // Move the points in the node to the child node that should contain the point.\n  // Again, we can try inserting each point into all the child nodes. The wrong ones\n  // (where the point's position is outside the child node's boundary) would simply\n  // return false, until we find the correct child node.\n  node.points.forEach((point) => {\n    if (insert(node.topLeftChild, point)) return;\n    if (insert(node.bottomLeftChild, point)) return;\n    if (insert(node.topRightChild, point)) return;\n    if (insert(node.bottomRightChild, point)) return;\n  });\n\n  // We no longer need to keep the points in node\n  node.points = [];\n}\n\n/**\n * Returns all the points within the given boundary\n *\n * @param {Quadtree} node\n * @param {Boundary} boundary\n * @returns\n */\nfunction search(node, boundary) {\n  // If this node does not intersect with the search boundary,\n  // we know that the node and all its child nodes do not\n  // contain any points that fall into the search boundary\n  if (!intersects(node.boundary, boundary)) {\n    return [];\n  }\n\n  // If this node has not yet been subdivided, return\n  // all the points within the search boundary\n  if (!node.topLeftChild) {\n    return node.points.filter((point) => contains(boundary, point));\n  }\n\n  // If the node has been subdivided, search all\n  // the child nodes and merge the results\n  return search(node.topLeftChild, boundary)\n    .concat(search(node.bottomLeftChild, boundary))\n    .concat(search(node.topRightChild, boundary))\n    .concat(search(node.bottomRightChild, boundary));\n}\n\n/**\n * Returns true if the given boundary intersects with this boundary\n *\n * @param {Boundary} b1\n * @param {Boundary} b2\n * @returns\n */\nfunction intersects(b1, b2) {\n  return (\n    // not too right\n    b1.topLeft.x <= b2.bottomRight.x &&\n    // not too left\n    b1.bottomRight.x >= b2.topLeft.x &&\n    // not too down\n    b1.topLeft.y <= b2.bottomRight.y &&\n    // not too up\n    b1.bottomRight.y >= b2.topLeft.y\n  );\n}\n\n/**\n * Returns the nearest point to the given point\n *\n * @param {Quadtree} node\n * @param {Point} location\n * @param {{point: Point, distance: number} | undefined} nearestPoint\n * @returns\n */\nfunction nearest(\n  node,\n  location,\n  nearestPoint = {\n    point: null,\n    distance: distance(node.boundary.topLeft, node.boundary.bottomRight),\n  }\n) {\n  // If the boundary is farther than the nearest point, no need to check here or any of the child nodes\n  if (\n    Math.abs(location.x - node.boundary.topLeft.x) > nearestPoint.distance ||\n    Math.abs(location.x - node.boundary.bottomRight.x) > nearestPoint.distance ||\n    Math.abs(location.y - node.boundary.topLeft.y) > nearestPoint.distance ||\n    Math.abs(location.y - node.boundary.bottomRight.y) > nearestPoint.distance\n  ) {\n    return nearestPoint;\n  }\n\n  // Not yet subdivided, return the nearest point in this node\n  if (!node.topLeftChild) {\n    node.points.forEach((nodePoint) => {\n      const d = distance(nodePoint, location);\n      if (d < nearestPoint.distance) {\n        nearestPoint.point = nodePoint;\n        nearestPoint.distance = d;\n      }\n    });\n    return nearestPoint;\n  }\n\n  // Since this node has already been subdivided, check all its child nodes.\n  // Check the child node where the location falls first, before checking\n  // the adjacent nodes, and then the opposite node.\n\n  const childNodes = [\n    node.topLeftChild,\n    node.topRightChild,\n    node.bottomLeftChild,\n    node.bottomRightChild,\n  ];\n\n  // True if location is at the top half of this node's boundary\n  const tb = location.y < (node.boundary.topLeft.y + node.boundary.bottomRight.y) / 2;\n  // True if location is at the left half of this node's boundary\n  const lr = location.x < (node.boundary.topLeft.x + node.boundary.bottomRight.x) / 2;\n\n  // containing node\n  nearestPoint = nearest(childNodes[2 * (1 - tb) + 1 * (1 - lr)], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * (1 - tb) + 1 * lr], location, nearestPoint);\n  // adjacent node\n  nearestPoint = nearest(childNodes[2 * tb + 1 * (1 - lr)], location, nearestPoint);\n  // opposite node\n  nearestPoint = nearest(childNodes[2 * tb + 1 * lr], location, nearestPoint);\n\n  return nearestPoint;\n}\n\n/**\n * Returns the Euclidean distance between two points\n *\n * @param {Point} p1\n * @param {Point} p2\n * @returns\n */\nfunction distance(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\n\nfunction createNode(topLeft, bottomRight) {\n  return { boundary: { topLeft, bottomRight }, points: [] };\n}\n\nmodule.exports = { insert, search, nearest };\n","const d3 = require('d3');\nconst { insert } = require('./quadtree');\n\nconst width = 750;\nconst height = 300;\n\nconst svg = d3.select('body').append('svg').attr('width', width).attr('height', height);\n\nconst quadtree = {\n  boundary: {\n    topLeft: { x: 0, y: 0 },\n    bottomRight: { x: width, y: height },\n  },\n  points: [],\n  depth: 1,\n};\n\nconst color = d3.scaleLinear().domain([0, 8]).range(['#efe', '#060']);\n\nfunction nodes(quadtree) {\n  quadtree.depth = 0;\n\n  const nodes = [];\n  visit(quadtree, (node) => {\n    nodes.push(node);\n  });\n  return nodes;\n}\n\nfunction points(quadtree) {\n  return nodes(quadtree).flatMap((node) => node.points);\n}\n\nfunction visit(node, cb) {\n  cb(node);\n\n  if (node.topLeftChild) {\n    node.topLeftChild.depth = node.depth + 1;\n    visit(node.topLeftChild, cb);\n\n    node.topRightChild.depth = node.depth + 1;\n    visit(node.topRightChild, cb);\n\n    node.bottomLeftChild.depth = node.depth + 1;\n    visit(node.bottomLeftChild, cb);\n\n    node.bottomRightChild.depth = node.depth + 1;\n    visit(node.bottomRightChild, cb);\n  }\n}\n\nlet pts;\nlet rect;\n\nfunction draw() {\n  rect = rect.data(nodes(quadtree));\n  rect.exit().remove();\n  rect\n    .enter()\n    .append('rect')\n    .attr('class', 'node')\n    .attr('x', function (d) {\n      return d.boundary.topLeft.x;\n    })\n    .attr('y', function (d) {\n      return d.boundary.topLeft.y;\n    })\n    .attr('width', function (d) {\n      return d.boundary.bottomRight.x - d.boundary.topLeft.x;\n    })\n    .attr('height', function (d) {\n      return d.boundary.bottomRight.y - d.boundary.topLeft.y;\n    });\n\n  pts = pts.data(points(quadtree));\n  pts.exit().remove();\n  pts\n    .enter()\n    .append('circle')\n    .attr('class', 'point')\n    .attr('cx', function (d) {\n      return d.x;\n    })\n    .attr('cy', function (d) {\n      return d.y;\n    })\n    .attr('r', 3);\n\n  svg.selectAll('.node').style('fill', function (d) {\n    return color(d.depth);\n    // return d.visited ? color(d.depth) : 'none';\n  });\n}\n\nrect = svg\n  .selectAll('.node')\n  .data(nodes(quadtree))\n  .enter()\n  .append('rect')\n  .attr('class', 'node')\n  .attr('x', function (d) {\n    return d.boundary.topLeft.x;\n  })\n  .attr('y', function (d) {\n    return d.boundary.topLeft.y;\n  })\n  .attr('width', function (d) {\n    return d.boundary.bottomRight.x - d.boundary.topLeft.x;\n  })\n  .attr('height', function (d) {\n    return d.boundary.bottomRight.y - d.boundary.topLeft.y;\n  });\n\npts = svg\n  .selectAll('.point')\n  .data(points(quadtree))\n  .enter()\n  .append('circle')\n  .attr('class', 'point')\n  .attr('cx', function (d) {\n    return d.x;\n  })\n  .attr('cy', function (d) {\n    return d.y;\n  })\n  .attr('r', 3);\n\nfor (let i = 0; i < 300; i++) {\n  insert(quadtree, { x: Math.random() * width, y: Math.random() * height });\n}\n\ndraw();\n\n// setInterval(() => {\n//   insert(quadtree, { x: Math.random() * width, y: Math.random() * height });\n//   draw();\n// }, 100);\n"],"names":["$73dc4f22fc361a3a$var$insert","node","point","$73dc4f22fc361a3a$var$contains","boundary","points","length","topLeftChild","push","topLeft","bottomRight","midPoint","x","y","$73dc4f22fc361a3a$var$createNode","bottomLeftChild","topRightChild","bottomRightChild","forEach","$73dc4f22fc361a3a$var$subdivide","$73dc4f22fc361a3a$var$distance","p1","p2","Math","sqrt","pow","$73dc4f22fc361a3a$var$search","b1","b2","concat","filter","$73dc4f22fc361a3a$var$nearest","location","nearestPoint","distance","abs","nodePoint","d","childNodes","tb","lr","insert","$15c062d30dfc8ad5$var$svg","$EQ8Ao","select","append","attr","$15c062d30dfc8ad5$var$quadtree","depth","$15c062d30dfc8ad5$var$color","scaleLinear","domain","range","$15c062d30dfc8ad5$var$nodes","quadtree","nodes","$15c062d30dfc8ad5$var$visit","$15c062d30dfc8ad5$var$points","flatMap","cb","$15c062d30dfc8ad5$var$pts","$15c062d30dfc8ad5$var$rect","selectAll","data","enter","i","$15c062d30dfc8ad5$require$insert","random","exit","remove","style"],"version":3,"file":"3.f2c222e8.js.map"}