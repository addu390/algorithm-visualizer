{"mappings":"qfAEA,MAGMA,EAAOC,EAAAC,MAAS,KAAKC,KAAG,kBAHhB,IAIJC,KAAKC,SAHA,IAGkBD,KAAKC,aAGhCC,EAAML,EAAAM,OAAS,QAASC,OAAM,OAAQC,KAAI,QAPlC,KAOmDA,KAAI,SANtD,KAWTC,EAAWJ,EACdK,UAAS,SACTC,KAAI,EACDC,GAAI,EAAGC,GANAC,IAMUC,GAAI,EAAGC,GALjBC,MAMPL,GAPOE,IAOGD,GAhBF,IAgBaE,GAAI,EAAGC,GANrBC,MAOPL,GAAI,EAAGC,GARAC,IAQUC,GAPVE,IAOoBD,GAhBlB,MAiBTJ,GATOE,IASGD,GAlBF,IAkBaE,GARdE,IAQwBD,GAjBtB,OAmBZE,QACAX,OAAM,QACNC,KAAI,QAAQ,QACZA,KAAI,KAAI,SAAYW,UACZA,EAAEP,MAEVJ,KAAI,KAAI,SAAYW,UACZA,EAAEJ,MAEVP,KAAI,SAAQ,SAAYW,UAChBA,EAAEN,GAAKM,EAAEP,MAEjBJ,KAAI,UAAS,SAAYW,UACjBA,EAAEH,GAAKG,EAAEJ,MAIdK,EAAgB,IAAXjB,KAAKC,SACViB,EAAgB,IAAXlB,KAAKC,SAEVkB,EAAE,CAAKV,GAAIQ,EAAIP,GAAIO,EAJf,IAIuBL,GAAIM,EAAIL,GAAIK,EAJnC,KAyBJE,GAnBiBlB,EACpBK,UAAS,SACTC,KAAI,CAAEW,IACNJ,QACAX,OAAM,QACNC,KAAI,QAAQ,QACZA,KAAI,KAAI,SAAYW,UACZA,EAAEP,MAEVJ,KAAI,KAAI,SAAYW,UACZA,EAAEJ,MAEVP,KAAI,SAAQ,SAAYW,UAChBA,EAAEN,GAAKM,EAAEP,MAEjBJ,KAAI,UAAS,SAAYW,UACjBA,EAAEH,GAAKG,EAAEJ,MAGLV,EACZK,UAAS,UACTC,KAAKZ,GACLmB,QACAX,OAAM,UACNC,KAAI,QAAQ,SACZA,KAAI,MAAK,SAAYW,UACbA,EAAE,MAEVX,KAAI,MAAK,SAAYW,UACbA,EAAE,MAEVX,KAAI,IAAM,aAQJgB,EAASC,EAAGC,GACnB,MAAOC,EAAGC,GAAKH,GACVb,GAAGA,EAAEC,GAAEA,EAAEE,GAAEA,EAAEC,GAAEA,GAAOU,SACpBC,GAAKf,GAAMe,GAAKd,GAAMe,GAAKb,GAAMa,GAAKZ,EAT/CO,EAAOM,MAAMJ,IACPD,EAASC,EAAC,IAAIL,EAAIP,GAAIO,EAxClB,OAwC0BC,EAAIL,GAAIK,EAxClC,QAyCNI,EAAEK,UAAW,MAUjBP,EAAOQ,QAAO,YAAcN,GACnBA,EAAEK,WAIX,MAAME,EAAI,GACVvB,EAASoB,MAAMI,QAkBKC,EAAIC,EAAAA,EAjBEb,GAiBNY,EAjBHD,GAmBVrB,IAAMuB,EAAGtB,IACZqB,EAAGrB,IAAMsB,EAAGvB,IACZsB,EAAGnB,IAAMoB,EAAGnB,IACZkB,EAAGlB,IAAMmB,EAAGpB,IArBZiB,EAAKI,KAAKH,MAIdV,EAAOM,MAAMQ,IACXL,EAAKM,SAASC,IACRf,EAASa,EAAOE,KAClBF,EAAMG,UAAW,SAKvBjB,EAAOQ,QAAO,YAAcN,GACnBA,EAAEe","sources":["2.js"],"sourcesContent":["const d3 = require('d3');\n\nconst width = 750;\nconst height = 300;\n\nconst data = d3.range(100).map(function () {\n  return [Math.random() * width, Math.random() * height];\n});\n\nconst svg = d3.select('body').append('svg').attr('width', width).attr('height', height);\n\nconst midX = width / 2;\nconst midY = height / 2;\n\nconst sections = svg\n  .selectAll('.node')\n  .data([\n    { x1: 0, x2: midX, y1: 0, y2: midY },\n    { x1: midX, x2: width, y1: 0, y2: midY },\n    { x1: 0, x2: midX, y1: midY, y2: height },\n    { x1: midX, x2: width, y1: midY, y2: height },\n  ])\n  .enter()\n  .append('rect')\n  .attr('class', 'node')\n  .attr('x', function (d) {\n    return d.x1;\n  })\n  .attr('y', function (d) {\n    return d.y1;\n  })\n  .attr('width', function (d) {\n    return d.x2 - d.x1;\n  })\n  .attr('height', function (d) {\n    return d.y2 - d.y1;\n  });\n\nconst s = 100;\nconst x1 = Math.random() * (width - s);\nconst y1 = Math.random() * (height - s);\n\nconst sb = { x1: x1, x2: x1 + s, y1: y1, y2: y1 + s };\n\nconst searchBoundary = svg\n  .selectAll('.rect')\n  .data([sb])\n  .enter()\n  .append('rect')\n  .attr('class', 'rect')\n  .attr('x', function (d) {\n    return d.x1;\n  })\n  .attr('y', function (d) {\n    return d.y1;\n  })\n  .attr('width', function (d) {\n    return d.x2 - d.x1;\n  })\n  .attr('height', function (d) {\n    return d.y2 - d.y1;\n  });\n\nconst points = svg\n  .selectAll('.point')\n  .data(data)\n  .enter()\n  .append('circle')\n  .attr('class', 'point')\n  .attr('cx', function (d) {\n    return d[0];\n  })\n  .attr('cy', function (d) {\n    return d[1];\n  })\n  .attr('r', 3);\n\npoints.each((p) => {\n  if (contains(p, { x1, x2: x1 + s, y1, y2: y1 + s })) {\n    p.selected = true;\n  }\n});\n\nfunction contains(p, b) {\n  const [x, y] = p;\n  const { x1, x2, y1, y2 } = b;\n  return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n}\n\npoints.classed('selected', (p) => {\n  return p.selected;\n});\n\n// Get sections that intersect with sb\nconst ints = [];\nsections.each((section) => {\n  if (intersects(section, sb)) {\n    ints.push(section);\n  }\n});\n\npoints.each((point) => {\n  ints.forEach((int) => {\n    if (contains(point, int)) {\n      point.searched = true;\n    }\n  });\n});\n\npoints.classed('searched', (p) => {\n  return p.searched;\n});\n\nfunction intersects(b1, b2) {\n  return (\n    b1.x1 <= b2.x2 && // not too right\n    b1.x2 >= b2.x1 && // not too left\n    b1.y1 <= b2.y2 && // not too down\n    b1.y2 >= b2.y1 // not too up\n  );\n}\n"],"names":["$766df1ebc12b6515$var$data","$EQ8Ao","range","map","Math","random","$766df1ebc12b6515$var$svg","select","append","attr","$766df1ebc12b6515$var$sections","selectAll","data","x1","x2","$766df1ebc12b6515$var$width","y1","y2","$766df1ebc12b6515$var$height","enter","d","$766df1ebc12b6515$var$x1","$766df1ebc12b6515$var$y1","$766df1ebc12b6515$var$sb","$766df1ebc12b6515$var$points","$766df1ebc12b6515$var$contains","p","b","x","y","each","selected","classed","$766df1ebc12b6515$var$ints","section","b1","b2","push","point","forEach","int","searched"],"version":3,"file":"2.db27c433.js.map"}