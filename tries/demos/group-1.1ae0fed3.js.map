{"mappings":"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","sources":["tries/demos/d3.js","tries/trie.js"],"sourcesContent":["const d3 = require('d3');\nconst { alphabet } = require('../trie');\n\n/**\n * @typedef {{name: string, children: D3Tree[], isEndOfWord?: boolean, checked?: boolean}} D3Tree\n */\n\nconst svg = d3.select('#chart').append('svg').attr('width', '100%').attr('height', '100%');\n\n/**\n * Returns a function that converts a tree to a D3-friendly version\n * @param {number} maxDepth Maximum depth where to put the full words (should be 0 for a regular prefix)\n * @returns {(tree: any, name?: string, depth?: number) => D3Tree}\n */\nfunction getToD3Tree(maxDepth = 0) {\n  return function toD3Tree(tree, name = '', depth = 0) {\n    if (maxDepth && depth === maxDepth + 1) {\n      return { name: tree, children: [] };\n    }\n\n    const node = { name, children: [], isEndOfWord: tree.isEndOfWord, checked: tree.checked };\n    (maxDepth === 1 ? tree : tree.children).forEach((child, i) => {\n      node.children.push(toD3Tree(child, alphabet[i], depth + 1));\n    });\n    return node;\n  };\n}\n\n/**\n * Renders the tree\n * @param {D3Tree} tree\n * @param {{x:number, y:number}} nodeSpacing\n */\nfunction updateTree(tree, nodeSpacing) {\n  const root = d3.tree().nodeSize([nodeSpacing.x, nodeSpacing.y])(d3.hierarchy(tree));\n\n  // The tree is 90 deg. rotated, so the x, y values are reversed from here on\n\n  let minX = Infinity;\n  let maxX = -minX;\n  root.each((d) => {\n    if (d.x < minX) minX = d.x;\n    if (d.x > maxX) maxX = d.x;\n  });\n\n  const height = maxX - minX + nodeSpacing.x / 2;\n\n  let graph = svg.selectAll('g.graph').data([true]);\n  const newGraph = graph\n    .enter()\n    .append('g')\n    .classed('graph', () => true)\n    .merge(graph)\n    .attr('transform', () => `translate(${20},${(3 / 5) * height})`);\n  graph.exit().remove();\n\n  const links = newGraph.selectAll('path').data(root.links());\n  links\n    .enter()\n    .append('path')\n    .attr('fill', 'none')\n    .attr('stroke', '#aaa')\n    .attr('stroke-opacity', 0.4)\n    .attr('stroke-width', 1.5)\n    .merge(links)\n    .attr(\n      'd',\n      d3\n        .linkHorizontal()\n        .x((d) => d.y)\n        .y((d) => d.x)\n    );\n  links.exit().remove();\n\n  const nodes = newGraph\n    .selectAll('g.node')\n    .data(\n      root.descendants(),\n      (d) => `${d.data.name}-${d.data.isEndOfWord}-${d.depth}-${d.data.checked}`\n    );\n\n  const newNodes = nodes\n    .enter()\n    .append('g')\n    .classed('node', () => true);\n  newNodes.append('circle').attr('fill', '#aaa').attr('r', 3);\n  newNodes\n    .append('text')\n    .text((d) => d.data.name)\n    .attr('dy', '0.32em')\n    .attr('x', (d) => (d.children ? -6 : 6))\n    .attr('text-anchor', (d) => (d.children ? 'end' : 'start'));\n  newNodes\n    .merge(nodes)\n    .classed('word', (d) => !!d.data.isEndOfWord)\n    .classed('checked-passed', (d) => d.data.checked === 'passed')\n    .classed('checked-failed', (d) => d.data.checked === 'failed')\n    .attr('transform', (d) => `translate(${d.y},${d.x})`);\n  nodes.exit().remove();\n}\n\nmodule.exports = { updateTree, getToD3Tree };\n","// prettier-ignore\nconst alphabet = [\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n  'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n  's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n];\n\n/**\n * @typedef {{children: Trie[], isEndOfWord?: boolean, checked?: string }} Trie\n */\n\n/**\n * Creates a new dictionary from the text\n * @param {string} text\n * @returns {Trie}\n */\nfunction parse(text) {\n  const words = text.split('\\n').filter((t) => t.length > 0);\n  return insertAll(words);\n}\n\n/**\n * Creates a new dictionary from a list of words\n * @param {string[]} words\n * @returns {Trie}\n */\nfunction insertAll(words) {\n  const dictionary = { children: new Array(26) };\n  words.forEach((word) => {\n    insert(dictionary, word);\n  });\n  return dictionary;\n}\n\n/**\n * Adds a word to the dictionary\n * @param {Trie} dictionary\n * @param {string} word\n */\nfunction insert(dictionary, word) {\n  let current = dictionary;\n\n  // For each character in the word...\n  for (let i = 0; i < word.length; i++) {\n    // Create a new child dictionary for this character\n    const index = alphabet.indexOf(word[i]);\n    if (!current.children[index]) {\n      current.children[index] = { isEndOfWord: false, children: new Array(26) };\n    }\n\n    // Update the current child dictionary\n    current = current.children[index];\n  }\n\n  // The deepest child dictionary represents the last character in the word\n  current.isEndOfWord = true;\n}\n\n/**\n * Returns true if the tree contains the prefix\n * @param {Trie} tree\n * @param {string} prefix\n * @returns\n */\nfunction hasPrefix(tree, prefix) {\n  let node = tree;\n\n  // For each character in the prefix...\n  for (let i = 0; i < prefix.length; i++) {\n    const index = alphabet.indexOf(prefix[i]);\n\n    // If there is no child tree, there\n    // are no words starting with the prefix\n    if (!node.children[index]) {\n      node.checked = 'failed';\n      return false;\n    }\n\n    node = node.children[index];\n    node.checked = 'passed';\n  }\n\n  // If child trees exist till the end of the\n  // prefix, then the tree contains the prefix!\n  return true;\n}\n\n/**\n * Returns all the words in the dictionary that start with the prefix\n * @param {Trie} dictionary\n * @param {string} prefix\n * @returns\n */\nfunction startsWith(dictionary, prefix) {\n  let current = dictionary;\n\n  // For each character in the prefix...\n  for (let i = 0; i < prefix.length; i++) {\n    const index = alphabet.indexOf(prefix[i]);\n\n    // If there is no child dictionary, there\n    // are no words starting with the prefix\n    if (!current.children[index]) return [];\n\n    current = current.children[index];\n  }\n\n  // At the end of the prefix, we collect the words\n  // in the current child dictionary and its children\n  const matches = [];\n  collectWords(current, prefix, matches);\n  return matches;\n}\n\n/**\n * Collects all the words in the dictionary, prefixing them with `currentWord`\n * @param {Trie} dictionary\n * @param {string} currentWord\n * @param {string[]} words\n */\nfunction collectWords(dictionary, currentWord, words) {\n  // If the current dictionary is the end of the word, collect the word\n  if (dictionary.isEndOfWord) words.push(currentWord);\n\n  // Collect the words from each child dictionary\n  dictionary.children.forEach((childNode, i) => {\n    collectWords(childNode, currentWord + alphabet[i], words);\n  });\n}\n\nmodule.exports = { insert, startsWith, hasPrefix, alphabet, parse, insertAll };\n"],"names":["alphabet","$a219d5d1720c0d4a$var$svg","$h36xl","select","append","attr","module","exports","tree","nodeSpacing","root","nodeSize","x","y","hierarchy","minX","Infinity","maxX","each","d","height","graph","selectAll","data","newGraph","enter","classed","merge","exit","remove","links","linkHorizontal","nodes","descendants","name","isEndOfWord","depth","checked","newNodes","text","children","maxDepth","toD3Tree","node","forEach","child","i","push","$a219d5d1720c0d4a$require$alphabet","$c880e43055d1c5ed$var$alphabet","$c880e43055d1c5ed$var$insertAll","words","dictionary","Array","word","$c880e43055d1c5ed$var$insert","current","length","index","indexOf","$c880e43055d1c5ed$var$collectWords","currentWord","childNode","prefix","matches","split","filter","t"],"version":3,"file":"group-1.1ae0fed3.js.map"}