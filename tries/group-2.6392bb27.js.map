{"mappings":"kgBACMA,SCAN,MAAMC,EAAW,CACf,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACxC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACxC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,WAwEpB,iBArEDC,EAAYC,GAG1B,IAAIC,EAAUF,EAGd,MAAMG,EAAmBJ,EAASK,QAAQH,EAAK,IAS/C,GARKC,EAAQG,SAASF,KAEpBD,EAAQG,SAASF,GAAoB,CAAEG,aAAa,EAAOD,SAAU,IAAIE,MAAM,MAGjFL,EAAUA,EAAQG,SAASF,GAGP,IAAhBF,EAAKO,OAEP,YADAN,EAAQI,aAAc,GAKxB,MAAMG,EAAoBV,EAASK,QAAQH,EAAK,IAC3CC,EAAQG,SAASI,KACpBP,EAAQG,SAASI,GAAqB,CAAEH,aAAa,EAAOD,SAAU,IAAIE,MAAM,MAElFL,EAAUA,EAAQG,SAASI,GAGP,IAAhBR,EAAKO,OAMTN,EAAQG,SAASK,KAAKT,GALpBC,EAAQI,aAAc,IDlCpBK,oBACAC,WAEN,MAAMC,EAWG,gBAVQC,GACb,MAAMC,EAAQD,EAAKE,MAAM,MAAMC,QAAQC,GAAMA,EAAEV,OAAS,IAElDR,EAAa,CAAEK,SAAU,IAAIE,MAAM,KAIzC,OAHAQ,EAAMI,SAASlB,MACND,EAAYC,MAEdD,IAMLoB,EAAMC,EAAAC,OAAU,UAAUC,OAAO,OAAOC,KAAK,QAAS,QAAQA,KAAK,SAAU,iBAE1EC,EAASC,EAAMC,EAAO,GAAIC,EAAI,GAErC,GAAU,IAANA,EACF,MAAO,CAAED,KAAMD,EAAMrB,SAAU,IAGjC,MAAMwB,EAAO,MAAEF,EAAMtB,SAAU,GAAIC,YAAaoB,EAAKpB,aAIrD,OAHAoB,EAAKrB,SAASc,SAAO,CAAEW,EAAOC,KAC5BF,EAAKxB,SAASK,KAAKe,EAASK,EAAKE,EAAWD,GAAIH,EAAI,OAE/CC,EAGT,MAAMI,EAAc,CAAEC,EAAG,GAAIC,EAAG,KAE1BC,EACJ,wHACFf,EAAAC,OAAU,UACPe,SAAS,QAASD,GAClBE,GAAG,SAAUC,MACD1B,EAAW2B,MAAMD,EAAIE,OAAOC,OAAQjB,EAAUQ,EAAab,QAG/DP,EAAW2B,MAAMJ,GAAQX,EAAUQ,EAAab","sources":["tries/demos/group-2.js","tries/two-level-word-check.js"],"sourcesContent":["const d3 = require('d3');\nconst { alphabet } = require('../trie');\nconst { insert } = require('../two-level-word-check');\nconst { updateTree } = require('./graph');\n\nconst dictionary = (() => {\n  function parse(text) {\n    const words = text.split('\\n').filter((t) => t.length > 0);\n\n    const dictionary = { children: new Array(26) };\n    words.forEach((word) => {\n      insert(dictionary, word);\n    });\n    return dictionary;\n  }\n\n  return { parse };\n})();\n\nconst svg = d3.select('#chart').append('svg').attr('width', '100%').attr('height', '100%');\n\nfunction toD3Tree(tree, name = '', d = 0) {\n  // At depth 2, the tree is a word\n  if (d === 3) {\n    return { name: tree, children: [] };\n  }\n\n  const node = { name, children: [], isEndOfWord: tree.isEndOfWord };\n  tree.children.forEach((child, i) => {\n    node.children.push(toD3Tree(child, alphabet[i], d + 1));\n  });\n  return node;\n}\n\nconst nodeSpacing = { x: 15, y: 100 };\n\nconst value =\n  'fruit\\ndrain\\ntrip\\nanthem\\nelbow\\nsolid\\nin\\nappliance\\ndock\\ntribute\\nkick\\nsort\\nso\\nsquare\\neloquent\\na\\nthrive\\n';\nd3.select('#input')\n  .property('value', value)\n  .on('input', (evt) => {\n    updateTree(dictionary.parse(evt.target.value), toD3Tree, nodeSpacing, svg);\n  });\n\nupdateTree(dictionary.parse(value), toD3Tree, nodeSpacing, svg);\n","// prettier-ignore\nconst alphabet = [\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n  'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n  's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n];\n\nfunction insert(dictionary, word) {\n  // As we go deeper into the dictionary, we need to keep track\n  // of the current level we're on, starting from the root dictionary\n  let current = dictionary;\n\n  // Create a child dictionary for words starting with the first character\n  const firstLetterIndex = alphabet.indexOf(word[0]);\n  if (!current.children[firstLetterIndex]) {\n    // We've added an `isEndOfWord` flag to denote whether this child dictionary is itself a word\n    current.children[firstLetterIndex] = { isEndOfWord: false, children: new Array(26) };\n  }\n  // Update current to point to the child dictionary\n  current = current.children[firstLetterIndex];\n\n  // If the word has only one character, then the child dictionary is a word\n  if (word.length === 1) {\n    current.isEndOfWord = true;\n    return;\n  }\n\n  // Create a child dictionary for words starting with the second character\n  const secondLetterIndex = alphabet.indexOf(word[1]);\n  if (!current.children[secondLetterIndex]) {\n    current.children[secondLetterIndex] = { isEndOfWord: false, children: new Array(26) };\n  }\n  current = current.children[secondLetterIndex];\n\n  // If the word has two characters, then the current child dictionary is a word\n  if (word.length === 2) {\n    current.isEndOfWord = true;\n    return;\n  }\n\n  // The word has more than two characters, push it to the current child dictionary\n  current.children.push(word);\n}\n\nfunction startsWith(dictionary, prefix) {\n  const matches = [];\n\n  let current = dictionary;\n\n  if (prefix.length > 2) {\n    const grandChild =\n      dictionary.children[alphabet.indexOf(prefix[0])].children[alphabet.indexOf(prefix[1])];\n    return getMatches(grandChild, prefix);\n  }\n\n  return matches;\n}\n\n// Returns the prefix matches from a list\nfunction getMatches(dictionary, prefix) {\n  const matches = [];\n\n  for (let i = 0; i < dictionary.length; i++) {\n    const word = dictionary[i];\n\n    let prefixed = true;\n    for (let j = 0; j < prefix.length; j++) {\n      if (prefix[j] !== word[j]) prefixed = false;\n    }\n\n    if (prefixed) matches.push(word);\n  }\n\n  return matches;\n}\n\nmodule.exports = { insert };\n"],"names":["alphabet","$c106fecbbb5339fa$var$alphabet","dictionary","word","current","firstLetterIndex","indexOf","children","isEndOfWord","Array","length","secondLetterIndex","push","insert","updateTree","$372772ccd622c438$var$dictionary","text","words","split","filter","t","forEach","$372772ccd622c438$var$svg","$h36xl","select","append","attr","$372772ccd622c438$var$toD3Tree","tree","name","d","node","child","i","$372772ccd622c438$require$alphabet","$372772ccd622c438$var$nodeSpacing","x","y","$372772ccd622c438$var$value","property","on","evt","parse","target","value"],"version":3,"file":"group-2.6392bb27.js.map"}